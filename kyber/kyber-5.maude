--- Specification of CRYSTALS-KYBER till step 5
--- Author: Víctor García Valero <vicgarv2@upv.es>

--- Module specifying basic datatypes and its operations used in KYBER
fmod DATA-TYPES is
    protecting INT .
    --- Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    --- We also define type for matrices and polynomials
    sorts Vector Matrix .

    --- We specify that a vector is a also a matrix
    subsort Vector < Matrix .

    --- We specify numbers are vectors
    subsort Nat < Vector .

    vars V1 V2 V3 : Vector .

    --- Concatenation of vectors result in a new vector
    op _||_ : Vector Vector -> Vector .

    --- Operator for the sum of vectors
    op _v+_ : Vector Vector -> Vector [assoc comm] .

    --- Necessary equations for Dec step
    --- Identity element is 0
    eq V1 v+ 0 = V1 .

    --- Operator for the substraction of vectors
    op _v-_ : Vector Vector -> Vector [assoc] .

    --- Necessary equations for Dec step
    eq V1 v- V1 = 0 .
    eq (V1 v+ V2) v- V1 = V2 .
    --- This one is the most important because it allows us to eliminate ((A m* s) dot r)
    eq (V1 v+ V2) v- (V1 v+ V3) = V2 v- V3 .
    eq V1 v- 0 = V1 .

    --- Operator multiplication of a vector and a vector
    op _dot_ : Vector Vector -> Vector [assoc] .

    --- Equation to specify the distributive property of dot over v+
    eq (V1 v+ V2) dot V3 = (V1 dot V3) v+ (V2 dot V3) .
    eq V1 dot (V2 v+ V3) = (V1 dot V2) v+ (V1 dot V3) .

    var M1 : Matrix .

    --- Operator multiplication of a matrix and a vector
    op _m*_ : Matrix Vector -> Vector .

    --- Distributive property of dot over m*
    eq (M1 m* V1) dot V2 = V1 dot (M1 m* V2) .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Vector divided in two parts
    subsort Pair < Vector .

    op _,_ : Vector Vector -> Pair .

    --- First element of Pair
    op first : Pair -> Vector .
    eq first((V1,V2)) = V1 .
    --- Second element of Pair
    op second : Pair -> Vector .
    eq second((V1,V2)) = V2 .

    --- Constant and values necessary on modules for operations

    --- du and dv are integer parameters of CPAPKE in ENC and DEC
    ops du dv : -> NzNat .

    --- Rho and Sigma
    ops Rho1 Sig1 : -> Vector .
    ops Rho2 Sig2 : -> Vector .
    ops Rho3 Sig3 : -> Vector .

    --- Operation to represent the traspose of a given matrix or vector
    op tpM : Matrix -> Matrix .
    op tpV : Vector -> Vector .

    --- We define the distribution of the operation traspose over v+ and m*
    eq tpV(V1 v+ V2) = tpV(V1) v+ tpV(V2) .
    eq tpV(M1 m* V1) = tpM(M1) m* tpV(V1) . 
endfm

--- Module to specify all the hash functions that are used in the steps of KYBER KEM
fmod KYBER-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .

    --- Sample values taken from the set of byte-arrays of length 32
    ops d1 d2 d3 : -> Vector .

    --- G recieves a random number (vector) from the polynomial ring R and returns a pair of vectors
    op G : Vector -> Pair .
    eq G(d1) = (Rho1,Sig1) .
    eq G(d2) = (Rho2,Sig2) .
    eq G(d3) = (Rho3,Sig3) .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .

    --- Operators to compress and decompress
    ops Compress Decompress : Vector NzNat -> Vector .

    --- We assume the property leaves X ass the same, in practice this 
    --- is not true but a new X' is obteined which is close to X
    vars X V1 V2 : Vector .
    var N : NzNat .

    --- Property of interest
    eq Decompress(Compress(X,N),N) = X .
    eq Compress(Decompress(X,N),N) = X .

    --- Property of noise cancelation
    eq  (V1 v+ Decompress(X,N)) v- V2 = Decompress(X,N) .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod KYBER-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Public Square matrix A
    ops A1 A2 A3 A4 A5 : -> Matrix .

    --- Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector  -> Matrix .
    eq generateA(Rho1) = A1 .
    eq generateA(Rho2) = A2 .
    eq generateA(Rho3) = A3 .

    --- Constant values to represent s and e
    ops s1 e : -> Vector .
    ops s2 e' : -> Vector .
    ops s3 e'' : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig1) = s1 .
    eq sampleE(Sig1) = e .

    eq sampleS(Sig2) = s2 .
    eq sampleE(Sig2) = e' .

    eq sampleS(Sig3) = s3 .
    eq sampleE(Sig3) = e'' .
endfm

--- Module to represent the operations and data handled during ENC
fmod KYBER-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting ENCRYPTION .

    --- Message randomply generated by a principal
    ops m1 m2 m3 : -> Vector .

    --- Constant to represent the chosen coin r and the sampleR r'
    ops r1 r1' : -> Vector .
    ops r2 r2' : -> Vector .
    ops r3 r3' : -> Vector .

    op sampleR' : Vector -> Vector . 
    eq sampleR'(r1) = r1' .
    eq sampleR'(r2) = r2' .
    eq sampleR'(r3) = r3' .

    ops e11 e21 : -> Vector .
    ops e12 e22 : -> Vector .
    ops e13 e23 : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleE1 sampleE2 : Vector -> Vector .
    eq sampleE1(r1) = e11 .
    eq sampleE2(r1) = e21 .
    eq sampleE1(r2) = e12 .
    eq sampleE2(r2) = e22 .
    eq sampleE1(r3) = e13 .
    eq sampleE2(r3) = e23 .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod KYBER-CPAPKE-DEC is
    protecting DATA-TYPES .

    
endfm

--- CRYSTALS-KYBER
mod KYBER is
    --- IMPORTS-------------------------------
    ---protecting DATA-TYPES .
    protecting KYBER-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting KYBER-CPAPKE-KEYGEN .
    protecting KYBER-CPAPKE-ENC .

    --- SORTS---------------------------------
    
    sorts Identifier Principal Content Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Vector < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    sort GlobalState .
    
    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK interceptedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC interceptedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    --- We declare a sort for all the list of samples
    ---sorts Sample Samples .
    ---subsorts Vector < Sample < Samples .

    op emptyS : -> Content .

    --- Group of vectors d that can be sampled
    op ds : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of coins r that can be sampled
    op rs : Content -> Content .

    --- Operator to assign a vector 'd' to a participant
    op dI : Identifier Vector -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Vector -> Content .

    --- Operator to assign a random coin to a participant
    op rI : Identifier Vector -> Content .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Vector -> Content .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    --- Operation to check the network
    var M : Msg .
    vars MS1 MS2 : Msgs .

    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    ops Alice Eve Bob : ->  Identifier .
    --- Definition of the components of a Principal
    --- (idenifier that can be Alice, Bob or Eve [keys received or generated] content that the principal stores)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    var MSGS : Msgs .
    vars K1 K2 SK : SKey .
    vars PK PK' : PKey .
    vars U V U' V' : Vector .
    vars KS1 KS2 KS3 : Keys .
    vars C1 C2 : Vector .
    vars SAM1 SAM2 SAM3 : Vector .
    vars C C' : Pair .
    vars CONT CONT1 CONT2 CONT3 CONT4 CONT5 : Content .
    vars V1 V2 V3 : Vector .
    var M1 : Matrix .

    --- For simplyfing reasons we only sample d when there is no message on the network
    ---rl [SampleD] : { ds(SAM1 CONT emptyS) CONT1 } < (ID1[emptyK]emptyC) PS >net(emptyM) => { ds(CONT emptyS) CONT1 } < (ID1[emptyK]dI(ID1,SAM1)) PS >net(emptyM) .

    --- For now the protocol only starts when the participant can sample necesary values for keygen
    crl [KeyGen] : { ds(SAM1 CONT emptyS) CONT2 } < (ID1[emptyK]emptyC) PS >net(MSGS) => { ds(CONT emptyS) CONT2 } < (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]dI(ID1,SAM1) emptyC) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\ 
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) .

    --- Send PK to someone if it has not been sent before and the reciever didnt recieve it before
    crl [SendPK] : { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) PS >net(MSGS) => { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK})
        if (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\
        (msg{(ID1,ID2)[interceptedPK]PK}) in MSGS == false /\ 
        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .

    --- Last condition is to avoid receiveing Ciph as PK
    crl [RecievePK] : { CONT } < (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK}) => { CONT } < (ID2[publicKey(ID1,PK) ; KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[receivedPK]PK})
        if (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .
    
    --- Generation of ms when a participant has the pk of another participant
    ---crl [SampleM] : { ms(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]CONT1) PS >net(MSGS) => { ms(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM1) CONT1) PS >net(MSGS) 
        ---if  ID1 =/= ID2 .

    --- Generation of rs right after generating m
    ---rl [SampleR] : { rs(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM2) CONT1) PS >net(MSGS) => { rs(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]rI(ID1,SAM1) mI(ID1,SAM2) CONT1) PS >net(MSGS) .

    crl [Enc] : { ms(SAM1 CONT1 emptyS) rs(SAM2 CONT2 emptyS) CONT3 } < (ID2[publicKey(ID1,(M1 m* V1) v+ V2) ; KS2] CONT4) PS >net(MSGS) => { ms(CONT1 emptyS) rs(CONT2 emptyS) CONT3 } < (ID2[sharedKey(ID1,SAM1) ; publicKey(ID1,(M1 m* V1) v+ V2) ; KS2]cI(ID2,C) mI(ID2,SAM1) rI(ID2,SAM2) CONT4) PS >net(MSGS)
        if U := ((tpM(M1) m* sampleR'(SAM2)) v+ sampleE1(SAM2)) /\
        V := (((tpV((M1 m* V1) v+ V2) dot sampleR'(SAM2)) v+ sampleE2(SAM2)) v+ Decompress(SAM1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        ID1 =/= ID2 .

    crl [SendCiph] : { CONT } < (ID2[sharedKey(ID1,SAM1) ; KS1]cI(ID2,C) CONT1) PS >net(MSGS) => { CONT } < (ID2[sharedKey(ID1,SAM1) ; KS1]cI(ID2,C) CONT1) PS >net(MSGS msg{(ID2,ID1)[sentC](C)})
        if (msg{(ID2,ID1)[sentC](C)}) in MSGS == false /\
        (msg{(ID2,ID1)[interceptedC](C)}) in MSGS == false /\
        (msg{(ID2,ID1)[receivedC](C)}) in MSGS == false .

    crl [RecieveCiph] : { CONT } < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sentC](C)}) => { CONT } < (ID1[KS1]cI(ID2,C) CONT1) PS >net(MSGS msg{(ID2,ID1)[receivedC](C)})
        if (msg{(ID2,ID1)[receivedC](C)}) in MSGS == false .

    --- Once decompressed, the ciphertext is destroyed from local memory of the participant
    crl [Dec] : { CONT } < (ID1[secretKey(ID1,SK) ; KS1]dI(ID1,SAM1) cI(ID2,C') CONT1) (ID3[KS2]cI(ID3,C') mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS) => { CONT } < (ID1[secretKey(ID1,SK) ; sharedKey(ID2,K1) ; KS1]dI(ID1,SAM1) CONT1) (ID3[KS2]cI(ID3,C') mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) /\
        U := ((tpM(generateA(first(G(SAM1)))) m* sampleR'(SAM3)) v+ sampleE1(SAM3)) /\
        V := (((tpV(PK) dot sampleR'(SAM3)) v+ sampleE2(SAM3)) v+ Decompress(SAM2,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K1 := Compress(V' v- tpV(SK) dot U',1) /\
        ID1 =/= ID2 .

    rl [Comp] : { CONT } < (ID1[sharedKey(ID2,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; KS2]CONT2) PS >net(MSGS) => True .

    --- Intruder behaviour
    crl [Intercept1] : { CONT } < (Eve[publicKey(Eve,PK) ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[sentPK]PK'}) => { CONT } < (Eve[publicKey(Eve,PK) ; publicKey(Alice,PK') ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[interceptedPK]PK'} msg{(Alice,Bob)[sentPK]PK}) 
        if (msg{(Alice,Bob)[interceptedPK]PK'}) in MSGS == false .

    crl [Intercept2] : { CONT } < (Eve[publicKey(Eve,PK) ; KS1]cI(Eve,C') CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC]C}) => { CONT } < (Eve[publicKey(Eve,PK) ; KS1]cI(Eve,C') cI(Bob,C) CONT1) PS >net(MSGS msg{(Bob,Alice)[interceptedC]C} msg{(Bob,Alice)[sentC]C'}) 
        if (msg{(Bob,Alice)[interceptedC]C}) in MSGS == false /\
        C =/= C' .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    
    op init : -> GlobalState .
    eq init = {ds(d1 d2 emptyS) ms(m1 m2 emptyS) rs(r1 r2 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

--- Agreement search
search [1] init =>* True .
--- MITM Attack search
search [1] init =>* { CONT } < (ID1[sharedKey(ID3,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; sharedKey(ID3,K2) ; KS2]CONT2) (ID3[sharedKey(ID1,K2) ; KS3]CONT3) >net(MSGS)  .
---rew init .