--- Specification of CRYSTALS-KYBER till step 6
--- Author: Víctor García Valero <vicgarval@upv.es>

--- Module specifying basic datatypes and its operations used in KYBER
fmod DATA-TYPES is
    protecting INT .

    sort Data .

    --- Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    --- We also define type for matrices and polynomials
    sorts Vector Matrix .

    --- We specify that a vector is a also a matrix
    subsort Vector < Matrix .

    --- Vectors and matrices are data of our model
    subsorts Vector Matrix < Data .

    --- We specify numbers are vectors
    subsort Nat < Vector .

    vars V1 V2 V3 : Vector .

    --- Concatenation of vectors result in a new vector
    op _||_ : Vector Vector -> Vector .

    --- Operator for the sum of vectors
    op _v+_ : Vector Vector -> Vector [assoc comm] .

    --- Necessary equations for Dec step
    --- Identity element is 0
    eq V1 v+ 0 = V1 .
    eq 0 v+ V1 = V1 .

    --- Operator for the substraction of vectors
    op _v-_ : Vector Vector -> Vector [assoc] .

    --- Necessary equations for Dec step
    eq V1 v- V1 = 0 .
    eq (V1 v+ V2) v- V1 = V2 .
    --- This one is the most important because it allows us to eliminate ((A m* s) dot r)
    eq (V1 v+ V2) v- (V1 v+ V3) = V2 v- V3 .
    eq V1 v- 0 = V1 .

    --- Operator multiplication of a vector and a vector
    op _dot_ : Vector Vector -> Vector [assoc] .

    --- Equation to specify the distributive property of dot over v+
    eq (V1 v+ V2) dot V3 = (V1 dot V3) v+ (V2 dot V3) .
    eq V1 dot (V2 v+ V3) = (V1 dot V2) v+ (V1 dot V3) .

    var M1 : Matrix .

    --- Operator multiplication of a matrix and a vector
    ---op _m*_ : Matrix Vector -> Vector .
    op _m*_ : Matrix Matrix -> Vector .

    --- Distributive property of dot over m*
    eq (M1 m* V1) dot V2 = V1 dot (M1 m* V2) .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Vector divided in two parts
    subsort Pair < Vector .

    op [_,_] : Data Data -> Pair .

    vars D1 D2 : Data .

    --- First element of Pair
    op first : Pair -> Data .
    eq first([D1,D2]) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second([D1,D2]) = D2 .

    --- du and dv are integer parameters of ENC and DEC
    ops du dv : -> NzNat .

    --- Rho and Sigma
    ops Rho1 Sig1 : -> Vector .
    ops Rho2 Sig2 : -> Vector .
    ops Rho3 Sig3 : -> Vector .

    --- Operation to represent the traspose of a given matrix or vector
    op tpM : Matrix -> Matrix .
    op tpV : Vector -> Vector .

    --- We define the distribution of the operation traspose over v+ and m*
    eq tpV(V1 v+ V2) = tpV(V1) v+ tpV(V2) .
    ---eq tpV(M1 m* V1) = tpM(M1) m* tpV(V1) . 
    eq tpV(M1 m* V1) = tpV(V1) m* tpM(M1) . 
endfm

--- Module to specify all the hash functions that are used in the steps of KYBER KEM
fmod KYBER-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .

    --- Sample values taken from the set of byte-arrays of length 32
    ops d1 d2 d3 : -> Vector .

    --- G recieves a random number (vector) from the polynomial ring R and returns a pair of vectors
    op G : Vector -> Pair .
    eq G(d1) = ([Rho1,Sig1]) .
    eq G(d2) = ([Rho2,Sig2]) .
    eq G(d3) = ([Rho3,Sig3]) .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod KYBER-KEYGEN is
    protecting DATA-TYPES .

    --- Public Square matrix A
    ops A1 A2 A3 A4 A5 : -> Matrix .

    --- Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector  -> Matrix .
    eq generateA(Rho1) = A1 .
    eq generateA(Rho2) = A2 .
    eq generateA(Rho3) = A3 .

    --- Constant values to represent s and e
    ops s1 e : -> Vector .
    ops s2 e' : -> Vector .
    ops s3 e'' : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig1) = s1 .
    eq sampleE(Sig1) = e .

    eq sampleS(Sig2) = s2 .
    eq sampleE(Sig2) = e' .

    eq sampleS(Sig3) = s3 .
    eq sampleE(Sig3) = e'' .
endfm

--- Module to represent the operations and data handled during ENC
fmod KYBER-ENC is
    protecting DATA-TYPES .

    --- Message randomply generated by a principal
    ops m1 m2 m3 : -> Vector .

    --- Constant to represent the chosen coin r and the sampleR r'
    ops r1 r1' : -> Vector .
    ops r2 r2' : -> Vector .
    ops r3 r3' : -> Vector .

    op sampleR' : Vector -> Vector . 
    eq sampleR'(r1) = r1' .
    eq sampleR'(r2) = r2' .
    eq sampleR'(r3) = r3' .

    ops e11 e21 : -> Vector .
    ops e12 e22 : -> Vector .
    ops e13 e23 : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleE1 sampleE2 : Vector -> Vector .
    eq sampleE1(r1) = e11 .
    eq sampleE2(r1) = e21 .
    eq sampleE1(r2) = e12 .
    eq sampleE2(r2) = e22 .
    eq sampleE1(r3) = e13 .
    eq sampleE2(r3) = e23 .
endfm

--- Module to represent the operations and data handled during DEC
fmod KYBER-DEC is
    protecting DATA-TYPES .
    
    --- Operators to compress and decompress
    ops Compress Decompress : Vector NzNat -> Vector .

    --- We assume the property leaves X ass the same, in practice this 
    --- is not true but a new X' is obteined which is close to X
    vars X V1 V2 : Vector .
    var N : NzNat .

    --- Property of interest
    eq Decompress(Compress(X,N),N) = X .
    eq Compress(Decompress(X,N),N) = X .

    --- Property of noise cancelation
    eq  (V1 v+ Decompress(X,N)) v- V2 = Decompress(X,N) .
endfm

--- Specification of the system upon KYBER will work
fmod MODEL-CONFIGURATION is
    protecting DATA-TYPES .

    --- SORTS---------------------------------
    sorts Identifier Content Principal Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    --- Sort for the State of our system
    sort GlobalState .

    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    var K : Key .
    vars KS1 KS2 : Keys .

    --- Operation to check the precence of a key in a participant
    op _in_ : Key Keys -> Bool .
    eq K in (KS1 ; K ; KS2) = true .
    eq K in (KS1) = false [owise] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey [format (g! o)] .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc comm id: emptyC] .

    vars C CONT1 CONT2 : Content .

    --- Operation to check the contents of a participant
    op _in_ : Content Content -> Bool .
    eq C in (CONT1 C CONT2) = true .
    eq C in (CONT1) = false [owise] .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .

    --- Group of messsages
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM format (d nt d)] .

    var M : Msg .
    vars MS1 MS2 : Msgs .
    
    --- Operation to check the network
    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    --- Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier [ctor] .

    op none : -> Identifier [ctor] .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Data -> Content .

    --- Operator to mark the current participant to whom the key exchange is happening
    op peer : Identifier -> Content .

    --- Definition of the components of a Principal
    --- (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Principal [ctor] .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm format (d n d)] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState [ctor format (n d d n n n d d d d)] .
endfm

--- CRYSTALS-KYBER
mod KYBER is
    --- IMPORTS-------------------------------
    protecting DATA-TYPES .
    protecting KYBER-HASH-OPERATIONS .
    protecting KYBER-KEYGEN .
    protecting KYBER-ENC .
    protecting KYBER-DEC .
    protecting MODEL-CONFIGURATION .

    subsorts Vector Matrix < Content .
    subsorts Vector < PKey SKey .

    --- Group of vectors d that can be sampled
    op ds : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of coins r that can be sampled
    op rs : Content -> Content .

    --- Operator to assign a vector 'd' to a participant
    op dI : Identifier Vector -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Vector -> Content .

    --- Operator to assign a random coin to a participant
    op rI : Identifier Vector -> Content .

    --- Operator to assign a Ciphered text to a participant
    ---op cI : Identifier Vector -> Content .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    ops init1 init2 : -> GlobalState .
    eq init1 = {ds(d1) ms(m1) rs(r1)} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .
    eq init2 = {ds(d1 d2) ms(m1 m2) rs(r1 r2)} < (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    var MSGS : Msgs .
    vars K1 K2 SK : SKey .
    vars PK PK' : PKey .
    vars U V U' V' : Vector .
    vars KS1 KS2 KS3 : Keys .
    vars C1 C2 : Vector .
    vars SAM1 SAM2 SAM3 : Data .
    vars C C' : Pair .
    vars CONT1 CONT2 CONT3 CONT4 : Content .
    vars V1 V2 V3 : Vector .
    var M1 : Matrix .

    --- For now the protocol only starts when the participant can sample necesary values for keygen
    crl [KeyGen] :  {ds(SAM1 CONT1) CONT4} < (ID1[emptyK]peer(none)) PS >net(MSGS) 
                    => 
                    {ds(CONT1) CONT4} < (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]dI(ID1,SAM1) peer(none)) PS >net(MSGS)
                    if  SK := sampleS(second(G(SAM1))) /\ 
                        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) .

    --- Send PK to someone if it has not been sent before and the reciever didnt recieve it before
    --- The publick key is sent "literally"
    crl [SendPK] :  {CONT4} < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) peer(none) CONT1) (ID2[KS2]peer(none)) PS >net(MSGS) 
                    => 
                    {CONT4} < (ID1[KS1]dI(ID1,SAM1) peer(ID2) CONT1) (ID2[KS2]peer(none)) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK})
                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\
                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false /\
                        (ID1 =/= ID2) .

    rl [ReceivePK] :   {CONT4} < (ID2[KS2]peer(none) CONT2) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK}) 
                        => 
                        {CONT4} < (ID2[publicKey(ID1,PK) ; KS2]peer(ID1) CONT2) PS >net(MSGS msg{(ID1,ID2)[receivedPK]PK}) .

    --- The public key is consumed to generate the shared key
    crl [Enc] : {ms(SAM1 CONT1) rs(SAM2 CONT3) CONT4} < (ID2[publicKey(ID1,(M1 m* V1) v+ V2) ; KS2]peer(ID1) CONT2) PS >net(MSGS) 
                => 
                {ms(CONT1) rs(CONT3) CONT4} < (ID2[sharedKey(ID1,SAM1) ; KS2]cI(ID1,C) mI(ID1,SAM1) rI(ID1,SAM2) peer(ID1) CONT2) PS >net(MSGS)
                if  ID1 =/= ID2 /\
                    U := ((tpM(M1) m* sampleR'(SAM2)) v+ sampleE1(SAM2)) /\
                    V := (((tpV((M1 m* V1) v+ V2) dot sampleR'(SAM2)) v+ sampleE2(SAM2)) v+ Decompress(SAM1,1)) /\
                    C1 := Compress(U,du) /\
                    C2 := Compress(V,dv) /\
                    C := ([C1,C2]) .

    --- The ciphered text is sent
    crl [SendCiph] :    {CONT4} < (ID2[sharedKey(ID1,SK) ; KS2]peer(ID1) cI(ID1,C) rI(ID1,SAM2) CONT2) PS >net(MSGS) 
                        => 
                        {CONT4} < (ID2[sharedKey(ID1,SK) ; KS2]peer(none) rI(ID1,SAM2) CONT2) PS >net(MSGS msg{(ID2,ID1)[sentC](C)})
                        if  (msg{(ID2,ID1)[sentC](C)}) in MSGS == false /\
                            (msg{(ID2,ID1)[receivedC](C)}) in MSGS == false .

    rl [ReceiveCiph] :  {CONT4} < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sentC](C)}) 
                        => 
                        {CONT4} < (ID1[KS1]cI(ID1,C) CONT1) PS >net(MSGS msg{(ID2,ID1)[receivedC](C)}) .

    --- Once decompressed, the ciphertext is destroyed from local memory of the participant
    --- The ciphered text is consumed
    crl [Dec] : {CONT4} < (ID1[secretKey(ID1,SK) ; KS1]peer(ID2) dI(ID1,SAM1) cI(ID1,C) CONT1) PS >net(MSGS) 
                =>
                {CONT4} < (ID1[sharedKey(ID2,K1) ; KS1]peer(none) CONT1) PS >net(MSGS)
                if  ID1 =/= ID2 /\
                    ID2 =/= none /\
                    U' := Decompress(first(C),du) /\
                    V' := Decompress(second(C),dv) /\
                    K1 := Compress(V' v- tpV(SK) dot U', 1) .

    --- Intruder behaviour
    crl [Intercept1] :  {CONT4} < (Eve[publicKey(Eve,PK') ; KS1]peer(none) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK}) 
                        => 
                        {CONT4} < (Eve[publicKey(ID1,PK) ; KS1]peer(ID1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK'}) 
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\ 
                            ID1 =/= ID2 /\
                            PK =/= PK' /\
                            (publicKey(ID1,PK)) in KS1 == false .

    crl [Intercept2] :  {CONT4} < (Eve[KS1]peer(ID2) cI(ID2,C') CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC]C}) 
                        => 
                        {CONT4} < (Eve[KS1]peer(ID1) cI(Eve,C) CONT1) PS >net(MSGS msg{(ID1,ID2)[sentC]C'})
                        if  ID1 =/= Eve /\
                            ID2 =/= Eve /\
                            ID1 =/= ID2 /\
                            C =/= C' /\
                            (cI(ID1,C)) in CONT1 == false .
endm