--- Specification of CRYSTALS-KYBER till step 3

--- Module specifying basic datatypes and its operations used in KYBER
fmod DATA-TYPES is
    protecting INT .
    --- Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    --- We also define type for matrices and polynomials
    sorts Vector Matrix .

    --- We specify that a vector is a also a matrix
    subsort Vector < Matrix .

    --- We specify numbers are vectors
    subsort Nat < Vector .

    vars V1 V2 V3 : Vector .

    --- Concatenation of vectors result in a new vector
    op _||_ : Vector Vector -> Vector .

    --- Operator for the sum of vectors
    op _v+_ : Vector Vector -> Vector [assoc] .

    --- Necessary equations for Dec step
    eq V1 v+ 0 = V1 .

    --- Operator for the substraction of vectors
    op _v-_ : Vector Vector -> Vector [assoc] .

    --- Necessary equations for Dec step
    eq V1 v- V1 = 0 .
    eq V1 v- 0 = V1 .

    --- Operator multiplication of a vector and a vector
    op _dot_ : Vector Vector -> Vector [assoc] .

    --- Equation to specify the distributive property of dot over v+
    eq (V1 v+ V2) dot V3 = (V1 dot V3) v+ (V2 dot V3) .
    eq V1 dot (V2 v+ V3) = (V1 dot V2) v+ (V1 dot V3) .

    var M1 : Matrix .

    --- Operator multiplication of a matrix and a vector
    op _m*_ : Matrix Vector -> Vector .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Vector divided in two parts
    subsort Pair < Vector .

    op _,_ : Vector Vector -> Pair .

    --- First element of Pair
    op first : Pair -> Vector .
    eq first((V1,V2)) = V1 .
    --- Second element of Pair
    op second : Pair -> Vector .
    eq second((V1,V2)) = V2 .

    --- Constant and values necessary on modules for operations

    --- du and dv are integer parameters of CPAPKE in ENC and DEC
    ops du dv : -> NzNat .

    --- Rho and Sigma
    ops Rho Sig : -> Vector .

    --- Constant values to represent s and e
    ops s e : -> Vector .

    --- Message randomply generated by a principal
    op m : -> Vector .

    --- Constant to represent the chosen coin r and the sampleR r'
    ops r r' : -> Vector .

    --- Operation to represent the traspose of a given matrix or vector
    op tpM : Matrix -> Matrix .
    op tpV : Vector -> Vector .

    --- We define the distribution of the operation traspose over v+ and m*
    eq tpV((V1 v+ V2)) = tpV(V1) v+ tpV(V2) .
    eq tpV(M1 m* V1) = tpM(M1) m* tpV(V1) .
endfm

--- Module to specify all the hash functions that are used in the steps of KYBER KEM
fmod KYBER-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .

    --- Sample values taken from the set of byte-arrays of length 32
    op d : -> Vector .

    --- G recieves a random number (vector) from the polynomial ring R and returns a pair of vectors
    op G : Vector -> Pair .
    eq G(d) = (Rho,Sig) .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .

    --- Operators to compress and decompress
    ops Compress Decompress : Vector NzNat -> Vector .

    --- We assume the property leaves X ass the same, in practice this 
    --- is not true but a new X' is obteined which is close to X
    vars X V1 V2 : Vector .
    var N : NzNat .

    --- Property of interest
    eq Decompress(Compress(X,N),N) = X .
    eq Compress(Decompress(X,N),N) = X .

    --- Property of noise cancelation
    eq  (V1 v+ Decompress(X,N)) v- V2 = Decompress(X,N) .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod KYBER-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Public Square matrix A
    ops A A2 A3 A4 A5 : -> Matrix .

    var RHO : Vector .

    --- Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector  -> Matrix .
    eq generateA(RHO) = A .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig) = s .
    eq sampleE(Sig) = e .
endfm

--- Module to represent the operations and data handled during ENC
fmod KYBER-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting ENCRYPTION .

    op sampleR' : Vector -> Vector . 
    eq sampleR'(r) = r' .

    ops e1 e2 : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleE1 sampleE2 : Vector -> Vector .
    eq sampleE1(r) = e1 .
    eq sampleE2(r) = e2 .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod KYBER-CPAPKE-DEC is
    protecting DATA-TYPES .

    
endfm

--- CRYSTALS-KYBER
mod KYBERV2 is
    --- IMPORTS-------------------------------
    protecting KYBER-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting KYBER-CPAPKE-KEYGEN .
    protecting KYBER-CPAPKE-ENC .

    --- SORTS---------------------------------
    
    sorts Identifier Principal Content Principals .
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs . 
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    ---We define keys as a type of content
    subsorts Vector < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    sort GlobalState .
    
    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    --- Posible states for a message
    ops sent received consumed intercepted : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    ops Alice Eve Bob : ->  Identifier .
    --- Definition of the components of a Principal
    --- (idenifier that can be Alice, Bob or Eve [keys received or generated] content that the principal stores)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Principals and a network with messages
    op <_>net(_) : Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    var PS : Principals .
    var MSGS : Msgs . 
    op k : -> Key .
    var K : Key .
    vars PK SK : Key .
    var U V U' V' : Vector .
    var KS1 KS2 : Keys .
    vars C1 C2 : Vector .
    var C : Pair .
    var CONT1 CONT2 : Content .

    --- For now the protocol only starts when the content of the participant is empty
    crl [KeyGen] : < (Alice[emptyK]emptyC) PS >net(emptyM) => < (Alice[PK ; SK]emptyC) PS >net(emptyM)
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .

    crl [SendPK] : < (Alice[PK ; KS1]CONT1) PS >net(emptyM) => < (Alice[PK ; KS1]CONT1) PS >net(msg{(Alice,Bob)[sent]PK})
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .

    crl [RecievePK] : < (Bob[KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[sent]PK}) => < (Bob[PK ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[received]PK})
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .
    
    crl [Enc] : < (Bob[PK ; KS1]CONT1) PS >net(MSGS msg{(Alice,Bob)[received]PK}) => < (Bob[m ; PK ; KS1]C CONT1) PS >net(MSGS msg{(Alice,Bob)[consumed]PK})
        if ---SK := sampleS(second(G(d))) /\ 
        ---PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
        U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
        V := (((tpV(PK) dot sampleR'(r)) v+ sampleE2(r)) v+ Decompress(m,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) .

    crl [SendCiph] : < (Bob[KS1]C CONT1) PS >net(MSGS msg{(Alice,Bob)[consumed]PK}) => < (Bob[KS1]C CONT1) PS >net(MSGS msg{(Alice,Bob)[consumed]PK} msg{(Bob,Alice)[sent](C)})
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
        U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
        V := (((tpV(PK) dot sampleR'(r)) v+ sampleE2(r)) v+ Decompress(m,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) .

    crl [RecieveCiph] : < (Alice[KS1]CONT1) PS >net(MSGS msg{(Bob,Alice)[sent](C)}) => < (Alice[KS1]CONT1 (C)) PS >net(MSGS msg{(Bob,Alice)[received](C)})
        if SK := sampleS(second(G(d))) /\
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
        U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
        V := ((tpV(PK) dot sampleR'(r)) v+ sampleE2(r) v+ Decompress(m,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) .

    crl [Dec] : < (Alice[SK ; KS1]C CONT1) PS >net(MSGS msg{(Bob,Alice)[received](C)}) => < (Alice[SK ; K ; KS1](C CONT1)) PS >net(MSGS msg{(Bob,Alice)[consumed](C)})
        if SK := sampleS(second(G(d))) /\
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
        U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
        V := (((tpV(PK) dot sampleR'(r)) v+ sampleE2(r)) v+ Decompress(m,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K := Compress(V' v- tpV(SK) dot U',1) .

    rl [Comp] : < (Alice[K ; KS1]CONT1) (Bob[K ; KS2]CONT2) PS >net(MSGS) => True .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    
    op init : -> GlobalState .
    eq init = < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

---search init =>* True .
rew init .