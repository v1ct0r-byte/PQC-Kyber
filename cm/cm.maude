--- Specification of CM
--- Author: Víctor García Valero <vicgarv2@upv.es>

--- Module specifying basic datatypes and its operations used in CM
fmod DATA-TYPES is
    sort Data .
    --- Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    sorts Vector Matrix Polynomial .
    subsort Vector Matrix Polynomial < Data .

    --- g is a monoic irreducible polynomial in F_2
    op g : -> Polynomial .

    --- Pair structure
    sort Pair .

    op _,_ : Data Data -> Pair .

    vars D1 D2 : Data .

    --- First element of Pair
    op first : Pair -> Data .
    eq first((D1,D2)) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second((D1,D2)) = D2 .

    --- Symbol to represent the value of the l-bits delta seed
    op delta : -> Vector .

    --- Functions for matrix generation

    
    ---
    ops I T : -> Matrix .

    --- Systematic form
    op _|_ : Matrix Matrix -> SystematicFormMatrix .
    eq I|T = 
endfm

--- Module to specify all the hash functions that are used in the steps of CM KEM
fmod CM-HASH-OPERATIONS is
    including DATA-TYPES .


endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    including DATA-TYPES .

    --- Cryptogram/Ciphertext
    op c : -> Vector .

    var V : Vector .
    var M : Matrix .

    --- Encodign subrutine
    op H : Vector Matrix -> Vector . 
    eq H(V,M) = c .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod CM-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Public key
    op T : -> Matrix .
    op s : -> Vector .

    --- Subfunction taking as imput the seed generated by keyGen and returning the pair of a secret and public keys
    op SeededKeyGen : Vector -> Pair .
    eq SeededKeyGen(delta) = ()

    --- Public key
    op T : -> Matrix .

    --- Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector  -> Matrix .
    eq generateA(Rho1) = A1 .
    eq generateA(Rho2) = A2 .
    eq generateA(Rho3) = A3 .

    --- Constant values to represent s and e
    ops s1 e : -> Vector .
    ops s2 e' : -> Vector .
    ops s3 e'' : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig1) = s1 .
    eq sampleE(Sig1) = e .

    eq sampleS(Sig2) = s2 .
    eq sampleE(Sig2) = e' .

    eq sampleS(Sig3) = s3 .
    eq sampleE(Sig3) = e'' .
endfm

--- Module to represent the operations and data handled during ENC
fmod CM-CPAPKE-ENC is
    
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod CM-CPAPKE-DEC is
    protecting DATA-TYPES .

    
endfm

--- CRYSTALS-CM
mod CM is
    --- IMPORTS-------------------------------
    ---protecting DATA-TYPES .
    protecting CM-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting CM-CPAPKE-KEYGEN .
    protecting CM-CPAPKE-ENC .

    --- SORTS---------------------------------
    
    sorts Identifier Principal Content Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Vector < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    sort GlobalState .
    
    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK interceptedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC interceptedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    --- We declare a sort for all the list of samples
    ---sorts Sample Samples .
    ---subsorts Vector < Sample < Samples .

    op emptyS : -> Content .

    --- Group of vectors d that can be sampled
    op ds : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of coins r that can be sampled
    op rs : Content -> Content .

    --- Operator to assign a vector 'd' to a participant
    op dI : Identifier Vector -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Vector -> Content .

    --- Operator to assign a random coin to a participant
    op rI : Identifier Vector -> Content .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Vector -> Content .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    --- Operation to check the network
    var M : Msg .
    vars MS1 MS2 : Msgs .

    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    ops Alice Eve Bob : ->  Identifier .
    --- Definition of the components of a Principal
    --- (idenifier that can be Alice, Bob or Eve [keys received or generated] content that the principal stores)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    var MSGS : Msgs .
    vars K1 K2 SK : SKey .
    vars PK PK' : PKey .
    vars U V U' V' : Vector .
    vars KS1 KS2 KS3 : Keys .
    vars C1 C2 : Vector .
    vars SAM1 SAM2 SAM3 : Vector .
    vars C C' : Pair .
    vars CONT CONT1 CONT2 CONT3 CONT4 CONT5 : Content .
    vars V1 V2 V3 : Vector .
    var M1 : Matrix .

    --- For simplyfing reasons we only sample d when there is no message on the network
    ---rl [SampleD] : { ds(SAM1 CONT emptyS) CONT1 } < (ID1[emptyK]emptyC) PS >net(emptyM) => { ds(CONT emptyS) CONT1 } < (ID1[emptyK]dI(ID1,SAM1)) PS >net(emptyM) .

    --- For now the protocol only starts when the participant can sample necesary values for keygen
    crl [KeyGen] : { ds(SAM1 CONT emptyS) CONT2 } < (ID1[emptyK]emptyC) PS >net(MSGS) => { ds(CONT emptyS) CONT2 } < (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]dI(ID1,SAM1) emptyC) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\ 
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) .

    --- Send PK to someone if it has not been sent before and the reciever didnt recieve it before
    crl [SendPK] : { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) (ID3[KS3]CONT3) >net(MSGS) => { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) (ID3[KS3]CONT3) >net(MSGS msg{(ID1,ID2)[sentPK]PK})
        if (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\
        (msg{(ID1,ID2)[interceptedPK]PK}) in MSGS == false /\ 
        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false /\
        (ID1 =/= ID2) /\ 
        (msg{(ID1,ID3)[sentPK]PK}) in MSGS == false /\
        (msg{(ID1,ID3)[interceptedPK]PK}) in MSGS == false /\ 
        (msg{(ID1,ID3)[receivedPK]PK}) in MSGS == false .

    --- Last condition is to avoid receiveing Ciph as PK
    crl [RecievePK] : { CONT } < (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[sentPK]PK}) => { CONT } < (ID2[publicKey(ID1,PK) ; KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[receivedPK]PK})
        if (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .
    
    --- Generation of ms when a participant has the pk of another participant
    ---crl [SampleM] : { ms(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]CONT1) PS >net(MSGS) => { ms(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM1) CONT1) PS >net(MSGS) 
        ---if  ID1 =/= ID2 .

    --- Generation of rs right after generating m
    ---rl [SampleR] : { rs(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM2) CONT1) PS >net(MSGS) => { rs(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]rI(ID1,SAM1) mI(ID1,SAM2) CONT1) PS >net(MSGS) .

    crl [Enc] : { ms(SAM1 CONT1 emptyS) rs(SAM2 CONT2 emptyS) CONT3 } < (ID2[publicKey(ID1,(M1 m* V1) v+ V2) ; KS2] CONT4) PS >net(MSGS) => { ms(CONT1 emptyS) rs(CONT2 emptyS) CONT3 } < (ID2[sharedKey(ID1,SAM1) ; publicKey(ID1,(M1 m* V1) v+ V2) ; KS2]cI(ID2,C) mI(ID2,SAM1) rI(ID2,SAM2) CONT4) PS >net(MSGS)
        if U := ((tpM(M1) m* sampleR'(SAM2)) v+ sampleE1(SAM2)) /\
        V := (((tpV((M1 m* V1) v+ V2) dot sampleR'(SAM2)) v+ sampleE2(SAM2)) v+ Decompress(SAM1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        ID1 =/= ID2 .

    crl [SendCiph] : { CONT } < (ID2[sharedKey(ID1,SAM1) ; publicKey(ID1,(M1 m* V1) v+ V2) ; KS1]cI(ID2,C) rI(ID2,SAM2) CONT1) PS >net(MSGS) => { CONT } < (ID2[sharedKey(ID1,SAM1) ; publicKey(ID1,(M1 m* V1) v+ V2) ; KS1]cI(ID2,C) rI(ID2,SAM2) CONT1) PS >net(MSGS msg{(ID2,ID1)[sentC](C)})
        if U := ((tpM(M1) m* sampleR'(SAM2)) v+ sampleE1(SAM2)) /\
        V := (((tpV((M1 m* V1) v+ V2) dot sampleR'(SAM2)) v+ sampleE2(SAM2)) v+ Decompress(SAM1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\
        (msg{(ID2,ID1)[sentC](C)}) in MSGS == false /\
        (msg{(ID2,ID1)[interceptedC](C)}) in MSGS == false /\
        (msg{(ID2,ID1)[receivedC](C)}) in MSGS == false .

    crl [RecieveCiph] : { CONT } < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sentC](C)}) => { CONT } < (ID1[KS1]cI(ID2,C) CONT1) PS >net(MSGS msg{(ID2,ID1)[receivedC](C)})
        if (msg{(ID2,ID1)[receivedC](C)}) in MSGS == false .

    --- Once decompressed, the ciphertext is destroyed from local memory of the participant
    crl [Dec] : { CONT } < (ID1[secretKey(ID1,SK) ; KS1]dI(ID1,SAM1) cI(ID2,C') CONT1) (ID3[KS2]cI(ID3,C') mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS) => { CONT } < (ID1[secretKey(ID1,SK) ; sharedKey(ID2,K1) ; KS1]dI(ID1,SAM1) CONT1) (ID3[KS2]cI(ID3,C') mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) /\
        U := ((tpM(generateA(first(G(SAM1)))) m* sampleR'(SAM3)) v+ sampleE1(SAM3)) /\
        V := (((tpV(PK) dot sampleR'(SAM3)) v+ sampleE2(SAM3)) v+ Decompress(SAM2,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K1 := Compress(V' v- tpV(SK) dot U',1) /\
        ID1 =/= ID2 .

    rl [Comp] : { CONT } < (ID1[sharedKey(ID2,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; KS2]CONT2) PS >net(MSGS) => True .

    --- Intruder behaviour
    crl [Intercept1] : { CONT } < (Eve[publicKey(Eve,PK) ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[sentPK]PK'}) => { CONT } < (Eve[publicKey(Eve,PK) ; publicKey(Alice,PK') ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[interceptedPK]PK'} msg{(Alice,Bob)[sentPK]PK}) 
        if (msg{(Alice,Bob)[interceptedPK]PK'}) in MSGS == false .

    crl [Intercept2] : { CONT } < (Eve[publicKey(Eve,PK) ; KS1]cI(Eve,C') CONT1) PS >net(MSGS msg{(Bob,Alice)[sentC]C}) => { CONT } < (Eve[publicKey(Eve,PK) ; KS1]cI(Eve,C') cI(Bob,C) CONT1) PS >net(MSGS msg{(Bob,Alice)[interceptedC]C} msg{(Bob,Alice)[sentC]C'}) 
        if (msg{(Bob,Alice)[interceptedC]C}) in MSGS == false /\
        C =/= C' .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    
    ops init init2 : -> GlobalState .
    eq init = {ds(d1 emptyS) ms(m1 emptyS) rs(r1 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
    eq init2 = {ds(d1 d2 emptyS) ms(m1 m2 emptyS) rs(r1 r2 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

--- Agreement search
search init =>* True .
--- MITM Attack search
search init =>* { CONT } < (ID1[sharedKey(ID3,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; sharedKey(ID3,K2) ; KS2]CONT2) (ID3[sharedKey(ID1,K2) ; KS3]CONT3) >net(MSGS)  .
---rew init .

--- Agreement search
search init2 =>* True .
--- MITM Attack search
search[1] init2 =>* { CONT } < (ID1[sharedKey(ID3,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; sharedKey(ID3,K2) ; KS2]CONT2) (ID3[sharedKey(ID1,K2) ; KS3]CONT3) >net(MSGS)  .
---rew init .