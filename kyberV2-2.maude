---Module with all operations needed to represent Vectors
fmod VECTOR is
    ---Here we are subsuming all sizes of vectors
    ---Posible sizes are (* -> arbitrary,32 -> 32 byte array)
    sort Vector .
    vars v1 v2 v3 : -> Vector .
    op _||_ : Vector Vector -> Vector .
    eq v1 || v2 = v3 .

    ---Tuple
    sort Tuple .
    op (_,_) : Vector Vector -> Tuple .
    ---First element of a tuple
    op first : Tuple -> Vector .
    eq first(v1,v2) = v1 .
    ---Second element of a tuple
    op second : Tuple -> Vector .
    eq second(v1,v2) = v2 .
endfm

---Module with all operations needed to represent Matrices
fmod MATRIX is
    ---A matrix is the product of two vectors of the same size
    sort Matrix .
    op _*_ : Vector Vector -> Matrix .
endfm

---Module with all operations needed to represent how Enc and Dec work
fmod ENCRYPT-DECRYPT-OPERATIONS is
    ---
    ---Hash functions
    op G : Vector -> Vector .
    op H : Vector -> Vector .

    ---Variables to represent the output of operations
    vars pk, sk : Vector .

    ---CPAPKE.KEYGEN
    op CPA : -> Tuple .
    eq CPA = (pk,sk) .
endfm
---Specification of CRYSTALS-KYBER
mod KYBERV2 is

    ---Sorts-------------------------------------------------------------------------------------------------------------
    sorts Identifier Principal Content Principals .
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs . 
    subsort Principal < Principals .

    sort Instr .

    sorts Key Keys .
    subsort Key < Keys .
    subsort Key < Content .
    
    sort Ciphertext .
    subsort Ciphertext < Content .

    sort GlobalState .

    ---Operators-------------------------------------------------------------------------------------------------------------

    ---Empty group of keys
    op emptyK : -> Keys .
    ---Group of keys
    op _|_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    ---Posible states for a message
    ops sent replied consumed intercepted : -> MsgState .

    ---Empty content
    op emptyC : -> Content .
    ---Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    ---Structure of a message
    ---Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [id: emptyM] .

    ops Alice Eve Bob : ->  Identifier .
    ---Definition of the components of a Principal
    ---Identifier(instruction[keys]messages)
    op (_[_]_) : Identifier Keys Content -> Principal .

    ---Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    ---Global state composed by Principals and a network with messages
    op <_>net(_) : Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    ---Rules-------------------------------------------------------------------------------------------------------------
    vars P1 P2 : Principal .
    var MSGS : Msgs .
    ---vars pk sk k : Key .
    ops pk sk k : -> Key .
    var ks : Keys .
    op Ciph : -> Ciphertext .
    var Cont Cont2 : Content .

    crl [KeyGen] : < (Alice[emptyK]emptyC) P1 P2 >net(emptyM) => < (Alice[pk | sk]emptyC) P1 P2 >net(emptyM) 
        ---Use of matching equations to model where do the values came from
        if  t := 
            p := 
            pk := (t || p) .

    rl [SendPK] : < (Alice[pk | ks]Cont) P1 P2 >net(emptyM) => < (Alice[pk | ks]Cont) P1 P2 >net(msg{(Alice,Bob)[sent]pk}) .

    rl [RecievePK] : < (Bob[ks]Cont) P1 P2 >net(MSGS msg{(Alice,Bob)[sent]pk}) => < (Bob[pk | ks]Cont) P1 P2 >net(MSGS msg{(Alice,Bob)[replied]pk}) .
    
    rl [Enc] : < (Bob[pk | ks]Cont) P1 P2 >net(MSGS msg{(Alice,Bob)[replied]pk}) => < (Bob[k | pk | ks]Ciph Cont) P1 P2 >net(MSGS msg{(Alice,Bob)[consumed]pk}).

    rl [SendCiph] : < (Bob[ks]Ciph Cont) P1 P2 >net(MSGS msg{(Alice,Bob)[consumed]pk}) => < (Bob[ks]Ciph Cont) P1 P2 >net(MSGS msg{(Bob,Alice)[consumed]pk} msg{(Bob,Alice)[sent]Ciph}) .

    rl [RecieveCiph] : < (Alice[ks]Cont) P1 P2 >net(MSGS msg{(Bob,Alice)[sent]Ciph}) => < (Alice[ks]Cont Ciph) P1 P2 >net(MSGS msg{(Bob,Alice)[replied]Ciph}) .

    rl [Dec] : < (Alice[sk | ks]Ciph Cont) P1 P2 >net(MSGS msg{(Bob,Alice)[replied]Ciph}) => < (Alice[sk | k | ks]Ciph Cont) P1 P2 >net(MSGS msg{(Bob,Alice)[consumed]Ciph}) .

    rl [Comp] : < (Alice[k | ks]Cont) (Bob[k | ks]Cont2) P2 >net(MSGS) => true .

    ---Initial state-------------------------------------------------------------------------------------------------------------
    op init : -> GlobalState .
    eq init = < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

---search in KYBERV2: init =>* True .