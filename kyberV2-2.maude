---Specification of CRYSTALS-KYBER till step 3

---Module specifying basic datatypes and its operations used in KYBER
fmod DATA-TYPES is
    protecting INT .
    ---Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    ---We also define type for matrices and polynomials
    sorts Vector Matrix .

    ---Concatenation of vectors result in a new vector
    op _||_ : Vector Vector -> Vector .

    ---Operator for the sum of vectors
    op _v+_ : Vector Vector -> Vector .

    vars m1 m2 m3 : Matrix .
    ---Operator multiplication of a matrix and a vector
    op _m*_ : Matrix Vector -> Vector .

    vars v1 v2 v3 : Vector .

    ---Pair
    sort Pair .
    op _,_ : Vector Vector -> Pair .
    ---First element of Pair
    op first : Pair -> Vector .
    eq first((v1,v2)) = v1 .
    ---Second element of Pair
    op second : Pair -> Vector .
    eq second((v1,v2)) = v2 .

    ---Constant and values necessary on modules for operations
    
    --- u and v are constants that represent obtained values
    ops u v : -> Vector .

    ---du and dv are integer parameters of CPAPKE in ENC and DEC
    ops du dv : -> NzNat .

    ---Rho and Sigma
    ops Rho Sig : -> Vector .

    ---Constant values to represent s and e
    ops s e : -> Vector .
endfm

---Module to specify all the hash functions that are used in the steps of KYBER KEM
fmod KYBER-HASH-OPERATIONS is
    protecting DATA-TYPES .

    ---H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .

    ---Sample values taken from the set of byte-arrays of length 32
    op d : -> Vector .

    ---G recieves a random number (vector) from the polynomial ring R and returns a pair of vectors
    op G : Vector -> Pair .
    eq G(d) = (Rho,Sig) .
    ---eq G(m||H(pk)) = (key1',r) .

    ops key1 key2 : -> Vector .

    ---Key Derivation Function receives a value and a hash value and derivates a key
    op KDF : Vector Vector -> Vector .
    ---eq KDF() = key1 .
endfm

---Module to specifiy basic operations and 
fmod ENCRYPTION is
    protecting DATA-TYPES .

    ---Operators to compress and decompress
    ops Compress Decompress : Vector NzNat -> Vector .

    ---Definition of Decompress
    ---eq decompress(decode(ciphertext),du) =  u .
    ---eq decompress(decode(c v+ du m* k *n/8), dv) = v .

    ---Property of interest
endfm

---Module to represent the operations and data handled during KEYGEN
fmod KYBER-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    ---Public Square matrix A
    op A : -> Matrix .

    ---Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector -> Matrix .
    eq generateA(Rho) = A .

    ---Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig) = s .
    eq sampleE(Sig) = e .
endfm

---Module to represent the operations and data handled during ENC
fmod KYBER-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting ENCRYPTION .

    op t : -> Vector .

    ---Decode de pk
    ---eq Decode((A m* s) v+ e) = t .

    op A' : -> Matrix .

    ---Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA' : Vector -> Matrix .
    eq generateA'(Rho) = A' .

    ops r r' : -> Vector .

    op sampleR' : Vector -> Vector . 
    eq sampleR'(r) = r' .

    ops e1 e2 : -> Vector .

    ---Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleE1 sampleE2 : Vector -> Vector .
    eq sampleE1(r) = e1 .
    eq sampleE2(r) = e2 .
endfm

---Module to represent the operations and data handled during DEC
---Its main purpouse is to demonstrate that the computed key is
---the one that originated c in Bob side using pk
fmod KYBER-CPAPKE-DEC is
    protecting DATA-TYPES .

    var ciphertext : Vector .
endfm

---CRYSTALS-KYBER
mod KYBERV2 is
    ---IMPORTS-------------------------------
    protecting KYBER-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting KYBER-CPAPKE-KEYGEN .
    protecting KYBER-CPAPKE-ENC .

    ---SORTS---------------------------------
    
    sorts Identifier Principal Content Principals .
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs . 
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    ***We define keys as a type of content
    subsorts Vector < Key < Content .
    
    ---sort Ciphertext .
    ---subsort Ciphertext < Vector < Content .

    sort GlobalState .
    
    ---OPERATORS----------------------------
    ---Empty group of keys
    op emptyK : -> Keys .
    ---Group of keys
    op _|_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    ---Posible states for a message
    ops sent received consumed intercepted : -> MsgState .

    ---Empty content
    op emptyC : -> Content .
    ---Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    ---Structure of a message
    ---Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [id: emptyM assoc] .

    ops Alice Eve Bob : ->  Identifier .
    ---Definition of the components of a Principal
    ---(idenifier that can be Alice, Bob or Eve [keys received or generated] content that the principal stores)
    op _[_]_ : Identifier Keys Content -> Principal .

    ---Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    ---Global state composed by Principals and a network with messages
    op <_>net(_) : Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    ---RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    var PS : Principals .
    var MSGS : Msgs . 
    op k : -> Key .
    vars pk sk : Key .
    var ks : Keys .
    vars Ciph c1 c2 : Vector .
    var Cont1 Cont2 : Content .

    crl [KeyGen] : < (Alice[emptyK]emptyC) PS >net(emptyM) => < (Alice[pk | sk]emptyC) PS >net(emptyM)
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) .

    crl [SendPK] : < (Alice[pk | ks]Cont1) PS >net(emptyM) => < (Alice[pk | ks]Cont1) PS >net(msg{(Alice,Bob)[sent]pk})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) .

    crl [RecievePK] : < (Bob[ks]Cont1) PS >net(MSGS msg{(Alice,Bob)[sent]pk}) => < (Bob[pk | ks]Cont1) PS >net(MSGS msg{(Alice,Bob)[received]pk})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) .
    
    crl [Enc] : < (Bob[pk | ks]Cont1) PS >net(MSGS msg{(Alice,Bob)[received]pk}) => < (Bob[k | pk | ks]Ciph Cont1) PS >net(MSGS msg{(Alice,Bob)[consumed]pk})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) /\
        c1 := Compress(u,du) /\
        c2 := Compress(v,dv) /\
        Ciph := c1 || c2 .

    crl [SendCiph] : < (Bob[ks]Ciph Cont1) PS >net(MSGS msg{(Alice,Bob)[consumed]pk}) => < (Bob[ks]Ciph Cont1) PS >net(MSGS msg{(Alice,Bob)[consumed]pk} msg{(Bob,Alice)[sent](Ciph)})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) /\
        c1 := Compress(u,du) /\
        c2 := Compress(v,dv) /\
        Ciph := c1 || c2 .

    crl [RecieveCiph] : < (Alice[ks]Cont1) PS >net(MSGS msg{(Bob,Alice)[sent](Ciph)}) => < (Alice[ks]Cont1 (Ciph)) PS >net(MSGS msg{(Bob,Alice)[received](Ciph)})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) /\
        c1 := Compress(u,du) /\
        c2 := Compress(v,dv) /\
        Ciph := c1 || c2 .

    crl [Dec] : < (Alice[sk | ks](Ciph Cont1)) PS >net(MSGS msg{(Bob,Alice)[received](Ciph)}) => < (Alice[sk | k | ks](Ciph Cont1)) PS >net(MSGS msg{(Bob,Alice)[consumed](Ciph)})
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) /\
        c1 := Compress(u,du) /\
        c2 := Compress(v,dv) /\
        Ciph := c1 || c2 .

    crl [Comp] : < (Alice[k | ks]Cont1) (Bob[k | ks]Cont2) PS >net(MSGS) => True
        if sk := sampleS(second(G(d))) /\ 
        pk := ((generateA(first(G(d))) m* sk) v+ sampleE(second(G(d)))) /\
        c1 := Compress(u,du) /\
        c2 := Compress(v,dv) /\
        Ciph := c1 || c2 .

    ---Initial state-------------------------------------------------------------------------------------------------------------
    
    op init : -> GlobalState .
    eq init = < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

---search in KYBERV2: init =>* True .