--- Specification of BIKE
--- Author: Víctor García Valero <vicgarv2@upv.es>

--- Module specifying basic datatypes and its operations used in BIKE
fmod DATA-TYPES is
    protecting INT .
    --- Supersort of all data
    sort Data . 
    --- Definition of type polynomial for our data
    sort Polynomial .

    --- We specify that polynomials is data
    subsorts Nat < Polynomial < Data .

    --- Operator addition of vectors
    op _p+_ : Polynomial Polynomial -> Polynomial [assoc comm prec 33] .

    --- --- Operator multiplication of matrices
    op _p*_ : Polynomial Polynomial -> Polynomial [assoc comm prec 31] .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Polynomial divided in two parts
    subsort Pair < Polynomial .

    op [_,_] : Data Data -> Pair .

    vars D1 D2 : Data .

    --- First element of Pair
    op first : Pair -> Data .
    eq first([D1,D2]) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second([D1,D2]) = D2 .

    --- Inverse operation over polynomials
    op inv : Polynomial -> Polynomial .
endfm

--- Module to specify all the hash functions that are used in the steps of BIKE KEM
fmod BIKE-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random polynomial and returns a hash of it (which is a pair of polynomials)
    op H : Polynomial -> Pair .
    op K : Polynomial Pair -> Polynomial .
    op L : Pair -> Polynomial .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .

    var D : Data .

    --- XOR
    op _xorD_ : Data Data -> Data [assoc comm] .
    eq D xorD 0 = D .
    eq D xorD D = 0 .
endfm

--- Module to represent the data and operations handled during KEYGEN
fmod BIKE-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Constant value representing the h_i sampled from the private key space H_w
    ops h0 h1 : -> Polynomial .

    --- Constant value representing the sigma obtained in step 3
    op sigma : -> Polynomial .
endfm

--- Module to represent the operations and data handled during ENC
fmod BIKE-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting ENCRYPTION .

    --- Messages randomply generated by a principal
    ops m1 m2 : -> Polynomial .

    --- Errors generated from H(M1)
    ops e0 e1 : -> Polynomial .
    eq H(m1) = [e0,e1] .

    --- Errors generated from H(M2)
    ops e0' e1' : -> Polynomial .
    eq H(m2) = [e0',e1'] .

    --- Operator to represent the shared key
    op k : -> Polynomial .
    var C : Pair .
    --- Key generated from K(m1,c)
    eq K(m1,C) = k .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod BIKE-CPAPKE-DEC is
    protecting DATA-TYPES .

    --- Operator to represent the decoder used (Black-Gray-Flip)
    op decoder : Polynomial Polynomial Polynomial -> Pair .
    
    vars P0 P1 P2 P3 : Polynomial .

    --- We only consider the perfect case where the obtained errors are the originals
    eq decoder((P0 p+ P1 p* P2 p* inv(P3)) p* P3, P3, P2) = [P0, P1] .
endfm

--- Specification of the system upon BIKE will work
fmod MODEL-CONFIGURATION is
    protecting DATA-TYPES .
    --- SORTS---------------------------------
    sorts Identifier Content Principal Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Polynomial < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    --- Sort for the State of our system
    sort GlobalState .

    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK interceptedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC interceptedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc comm id: emptyC] .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .

    --- Group of messsages
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    var M : Msg .
    vars MS1 MS2 : Msgs .
    
    --- Operation to check the network
    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    --- Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier .

    --- Definition of the components of a Principal
    --- (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState .
    op True : -> GlobalState . ---TODO: Should I leave it?
endfm

--- Protocol/mechanism samples and behaviour
mod BIKE is
    --- IMPORTS-------------------------------
    protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting BIKE-CPAPKE-KEYGEN .
    protecting BIKE-CPAPKE-ENC .
    protecting BIKE-CPAPKE-DEC .
    protecting MODEL-CONFIGURATION .

    --- Group of polynomials sigma that can be sampled
    op sigmas : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of polynomials h that can be sampled; They come in pairs
    op hs : Content -> Content .

    --- Operator to assign a polynomial 'sigma' to a participant
    op sigmaI : Identifier Polynomial -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Polynomial -> Content .

    --- Operator to assign a random pair of hs to a participant
    op hI : Identifier Pair -> Content .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Pair -> Content .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    ops init1 init2 : -> GlobalState .
    eq init1 = {sigmas(sigma) ms(m1) hs([h0,h1])} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
    --- eq init2 = {sigmas(d1 d2 emptyS) ms(m1 m2 emptyS) rs(r1 r2 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    var MSGS : Msgs .
    vars K1 K2 SK : SKey .
    vars PK PK' : PKey .
    vars C H E : Pair .
    vars C0 C1 : Polynomial .
    vars E0 E1 : Polynomial .
    var M : Polynomial .
    vars KS1 KS2 : Keys .
    vars SAM1 SAM2 : Data .
    vars CONT1 CONT2 CONT3 : Content .

    --- For now the protocol only starts when the participant can sample necesary values for keygen

    crl [KeyGen] :   {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]emptyC) PS >net(MSGS) 
                    => 
                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1, PK)]sigmaI(ID1,SAM1) hI(ID1, SAM2)) PS >net(MSGS) 
                    if PK := (second(SAM2) p* inv(first(SAM2))) .

    crl [SendPK] :  {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]CONT1) (ID2[KS2]CONT2) PS >net(MSGS)
                    =>
                    {CONT3} < (ID1[publicKey(ID1, PK) ; KS1]CONT1) (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})
                    if  (msg{(ID1,ID2)[sentPK]PK}) in MSGS == false /\ 
                        (msg{(ID1,ID2)[receivedPK]PK}) in MSGS == false .

    rl [ReceivePK] :    {CONT3} < (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1, ID2)[sentPK](PK)})
                        =>
                        {CONT3} < (ID2[KS2]publicKey(ID1, PK) CONT2) PS >net(MSGS msg{(ID1, ID2)[receivedPK](PK)}) .
    
    crl [Enc] : {ms(SAM1 CONT1) CONT3} < (ID2[KS2] publicKey(ID1, PK) CONT2) PS >net(MSGS)
                =>
                {ms(CONT1) CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] mI(ID2, SAM1) cI(ID2, C) publicKey(ID1, PK) CONT2) PS >net(MSGS)
                if  E := H(SAM1) /\
                    E0 := first(E) /\
                    E1 := second(E) /\
                    C := [(E0 p+ (E1 p* (PK))), (SAM1 xorD L(E))] /\
                    SK := K(SAM1, C) .
    
    crl [SendCiph] :    {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] cI(ID2, C) CONT2) PS >net(MSGS)
                        =>
                        {CONT3} < (ID2[KS2 ; sharedKey(ID1, SK)] cI(ID2, C) CONT2) PS >net(MSGS msg{(ID2, ID1)[sentC](C)}) 
                        if  (msg{(ID2, ID1)[sentC](C)}) in MSGS == false /\ 
                            (msg{(ID2, ID1)[receivedC](C)}) in MSGS == false .
    
    rl [ReceiveCiph] :  {CONT3} < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2, ID1)[sentC](C)}) 
                        =>
                        {CONT3} < (ID1[KS1]cI(ID2, C) CONT1) PS >net(MSGS msg{(ID2, ID1)[receivedC](C)})  .

    crl [Dec] :  {CONT3}< (ID1[publicKey(ID1, PK)]hI(ID1, H) cI(ID2, C) CONT1) PS >net(MSGS)
                =>
                {CONT3}< (ID1[publicKey(ID1, PK) ; sharedKey(ID2, SK)]hI(ID1, H) cI(ID2, C) CONT1) PS >net(MSGS) 
                if  E := decoder(first(C) p* first(H), first(H),second(H)) /\
                    E0 := first(E) /\
                    E1 := second(E) /\
                    M := second(C) xorD L(E) /\
                    SK := K(M,C) .
endm

rew init1 .

--- search init1 =>! {CONT1} < PS >net(MSGS) .