--- Specification of BIKE
--- Author: Víctor García Valero <vicgarv2@upv.es>

--- Module specifying basic datatypes and its operations used in BIKE
fmod DATA-TYPES is
    protecting INT .
    --- Supersort of all data
    sort Data . 

    --- We subsume all sizes of vectors (and abstract that all vectors are column vectors)
    --- Definition of types for vectors and matrices
    sorts Vector Matrix .

    --- We specify that a vector is a also a matrix and both are data
    subsorts Vector < Matrix < Data .

    --- We specify numbers can be seen as vectors
    subsort Nat < Data .

    vars D1 D2 : Data .
    vars M1 M2 : Matrix .

    --- Operator multiplication of matrices
    op _m*_ : Matrix Matrix -> Matrix [assoc] .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Vector divided in two parts
    subsort Pair < Vector .

    op _,_ : Data Data -> Pair .

    --- First element of Pair
    op first : Pair -> Data .
    eq first((D1,D2)) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second((D1,D2)) = D2 .

    --- du and dv are integer parameters of CPAPKE in ENC and DEC
    ops du dv : -> NzNat .

    --- Operation to represent the traspose of a given matrix or vector
    op tp : Matrix -> Matrix .
    op tp : Vector -> Vector .

    --- --- We define the distribution of the operation traspose over v+ and m*
    --- eq tp(V1 + V2)= tp(V1) + tp(V2) .
    --- ---eq tp(M1 * V1) = tp(M1) * tp(V1) . 
    --- eq tp(M1 * V1)= tp(V1) * tp(M1) . 

    --- Inverse operation over vectors
    op inv : Vector -> Vector .
endfm

--- Module to specify all the hash functions that are used in the steps of BIKE KEM
fmod BIKE-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .
    op K : Vector Vector Vector -> Vector .
    op L : Pair -> Vector .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .

    var D : Data .

    --- XOR
    op _xorD_ : Data Data -> Data [assoc comm] .
    eq D xorD 0 = D .
    eq D xorD D = 0 .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod BIKE-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Constant value representing the h_i sampled from the private key space H_w
    ops h0 h1 : -> Vector .

    --- Constant value representing the sigma obtained in step 3
    op sigma : -> Vector .
endfm

--- Module to represent the operations and data handled during ENC
fmod BIKE-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting ENCRYPTION .

    --- Messages randomply generated by a principal
    ops m1 m2 : -> Vector .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod BIKE-CPAPKE-DEC is
    protecting DATA-TYPES .

endfm

--- CRYSTALS-BIKE
mod BIKE is
    --- IMPORTS-------------------------------
    ---protecting DATA-TYPES .
    protecting BIKE-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting BIKE-CPAPKE-KEYGEN .
    protecting BIKE-CPAPKE-ENC .

    --- SORTS---------------------------------
    
    sorts Identifier Content Principal Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Vector < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    --- Sort for the State of our system
    sort GlobalState .
    
    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK interceptedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC interceptedC : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc comm id: emptyC] .

    --- Group of vectors sigma that can be sampled
    op sigmas : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of vectors h that can be sampled; They come in pairs
    op hs : Content -> Content .

    --- Operator to assign a vector 'sigma' to a participant
    op sigmaI : Identifier Vector -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Vector -> Content .

    --- Operator to assign a randompair of hs to a participant
    op hI : Identifier Pair -> Content .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Vector -> Content .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    --- Operation to check the network
    var M : Msg .
    vars MS1 MS2 : Msgs .

    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    --- Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier .

    --- Definition of the components of a Principal
    --- (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    --- Initial state-------------------------------------------------------------------------------------------------------------
    ops init1 init2 : -> GlobalState .
    eq init1 = {sigmas(sigma) ms(m1) hs((h0,h1))} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
    --- eq init2 = {sigmas(d1 d2 emptyS) ms(m1 m2 emptyS) rs(r1 r2 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    var MSGS : Msgs .
    vars K1 K2 SK : SKey .
    vars PK PK' : PKey .
    vars U V U' V' : Vector .
    vars KS1 KS2 KS3 : Keys .
    vars C1 C2 : Vector .
    vars SAM1 SAM2 SAM3 : Data .
    vars C C' : Pair .
    vars CONT1 CONT2 CONT3 CONT4 CONT5 : Content .
    vars V1 V2 V3 : Vector .
    var M1 : Matrix .

    --- For now the protocol only starts when the participant can sample necesary values for keygen
    --- crl [KeyGen] :  { sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3 } < (ID1[emptyK]emptyC) PS >net(MSGS) 
    ---             => 
    ---                 { sigmas(CONT1) hs(CONT2) CONT3 } < (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]sigmaI(ID1,SAM1) hI(ID1,SAM2)) PS >net(MSGS)
    ---     if SK := (first(SAM2), second(SAM2), SAM1) /\ 
    ---     PK := (second(SAM2) m* inv(first(SAM2))) .

    crl [KeyGen] :  {sigmas(SAM1 CONT1) hs(SAM2 CONT2) CONT3} < (ID1[emptyK]emptyC) PS >net(MSGS) 
                => 
                    {sigmas(CONT1) hs(CONT2) CONT3} < (ID1[publicKey(ID1,PK)]sigmaI(ID1,SAM1) hI(ID1,SAM2)) PS >net(MSGS)
        if PK := (second(SAM2) m* inv(first(SAM2))) .
endm

--- --- Agreement search
--- search init =>* True .
--- --- MITM Attack search
--- search init =>* { CONT } < (ID1[sharedKey(ID3,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; sharedKey(ID3,K2) ; KS2]CONT2) (ID3[sharedKey(ID1,K2) ; KS3]CONT3) >net(MSGS)  .
--- ---rew init .

--- --- Agreement search
--- search init2 =>* True .
--- --- MITM Attack search
--- search[1] init2 =>* { CONT } < (ID1[sharedKey(ID3,K1) ; KS1]CONT1) (ID2[sharedKey(ID1,K1) ; sharedKey(ID3,K2) ; KS2]CONT2) (ID3[sharedKey(ID1,K2) ; KS3]CONT3) >net(MSGS)  .
--- ---rew init .