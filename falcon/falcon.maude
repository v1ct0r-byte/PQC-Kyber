--- Specification of FALCON
--- Author: Víctor García Valero <vicgarval@upv.es>

--- Module specifying basic datatypes and the operations
fmod DATA-TYPES is
    protecting NAT .
    protecting STRING .

    --- Supersort of all data
    sort Data .

    --- Definitions of types of data
    sort Polynomial .
    sort Matrix .

    --- We specify that polynomials are data
    subsort Polynomial < Data .
    --- Furthermore, natural numbers can be seen as polynomials
    subsort Nat < Polynomial .
    --- We specify that matrices are data
    subsort Matrix < Data .

    --- Concatenation operation between Strings and natural numbers
    op _||_ : String Nat -> String .
    op _||_ : Nat String -> String .

    --- Substraction between Polynomials
    op _p-_ : Polynomial Polynomial -> Polynomial .

    --- Product between Polynomials
    op _p*_ : Polynomial Polynomial -> Polynomial .

    --- Inverse notation of a polynomial
    op inv : Polynomial -> Polynomial .

    --- Modulus operation
    op _mod_ : Polynomial Nat -> Polynomial .

    --- Symbolic constant to represent the length of a polynomial S
    op SBYTELEN : -> Nat .

    --- Compress and decompress operations
    ops Compress Decompress : Polynomial Nat -> Polynomial .
    eq Compress(Decompress(P:Polynomial,N:Nat),N:Nat) = P:Polynomial .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Polynomial divided in two parts
    subsort Pair < Polynomial .

    op [_,_] : Data Data -> Pair [ctor] .

    vars D1 D2 : Data .

    --- First element of Pair
    op first : Pair -> Data .
    eq first([D1,D2]) = D1 .
    --- Second element of Pair
    op second : Pair -> Data .
    eq second([D1,D2]) = D2 .
endfm

--- View to associate Data as elements of view TRIV, later used in LIST
view Data from TRIV to DATA-TYPES is
  sort Elt to Data .
endv

---Module to extend add operations and concepts of DATA-TYPES regarding lists of data
mod DATA-TYPES-EXT is
    protecting DATA-TYPES .
    protecting LIST{Data} .

    --- Ground operator
    op ground : -> Polynomial [ctor] .

    var L : List{Data} .
    var N : Nat .
    
    --- Operation to access an element in a List of Polynomials
    op elem : Nat List{Data} -> Data .
    eq elem(N, nil) = ground .
    eq elem(0, L) = ground .
    eq elem(1, L) = head(L) .
    eq elem(s(N), L) = elem(N, tail(L)) .
endm

--- Module to specify all the hash functions used during the protocol
fmod FALCON-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- Symbolic natural constant to represent any degree given of a polynomial
    op n : -> Nat .

    --- Hash operation that receives a string to hash, a modulus and a degree
    op HashToPoint : String Nat Nat -> Polynomial .
endfm

--- Module to represent the operations and data handled during KEYGEN step
fmod FALCON-KEYGEN is
    protecting DATA-TYPES .
    protecting LIST{Data} .

    --- Sample values for KeyGeneration
    op phi : -> Polynomial .
    op q : -> Nat .

    --- Sampler of values f, g, F and G
    op NTRUGen : Polynomial Nat -> List{Data} .
    ops f g F G : -> Polynomial .

    eq NTRUGen(phi, q) = (f g F G) .

    --- Matrix of a set of polynomials (this is to construct B)
    op mat : List{Data} -> Matrix .

    --- Fast Fourier Transformation
    op FFT : Matrix -> Polynomial .

    --- Matrix product
    op _x_ : Polynomial Polynomial -> Matrix .

    --- Fast Fourier LDL
    op ffLDL : Matrix -> Polynomial .
endfm

--- Module to represent the operations and data handled during SIGN
fmod FALCON-SIGN is
    protecting DATA-TYPES .
    protecting FALCON-KEYGEN .

    --- Sample values for r
    op r : -> Nat .

    --- Sample values for messages
    op m : -> String .

    --- Fast Fourier Sampling
    op ffSampling : Polynomial Polynomial -> Polynomial .

    --- Constant values to represent an instance of s_1 and s_2
    ops s1 s2 : -> Polynomial .

    --- Inverse Fast Fourier Transformation
    op invFFT : Polynomial -> Pair .
    eq invFFT((P1:Polynomial p- P2:Polynomial) p* FFT(M1:Matrix)) = ([s1,s2]) .

endfm

--- Module to represent the operations and data handled during VERIFY
fmod FALCON-VERIFY is
    protecting DATA-TYPES .

endfm

--- Module to set the foundations of our symbolic model
fmod MODEL-CONFIGURATION is
    protecting DATA-TYPES .
    protecting LIST{Data} .

    --- SORTS---------------------------------
    sorts Identifier Content Principal Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Polynomial < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    --- Declare Natural numbers and Strings as content
    subsorts Nat String < Content .

    --- Sort for the State of our system
    sort GlobalState .

    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc comm id: emptyK] .

    var K : Key .
    vars KS1 KS2 : Keys .

    --- Operation to check the precence of a key in a participant
    op _in_ : Key Keys -> Bool .
    eq K in (KS1 ; K ; KS2) = true .
    eq K in (KS1) = false [owise] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey [format (g! o)] .

    --- Posible states for a message delivering PK
    ops sentPK receivedPK : -> MsgState .
    --- Posible states for a message delivering C
    ops sentC receivedC : -> MsgState .

    --- Lists of data elements are content that can be stored
    subsort List{Data} < Content .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op _/_ : Content Content -> Content [assoc comm id: emptyC] .

    vars C CONT1 CONT2 : Content .

    --- Operation to check the contents of a participant
    op _in_ : Content Content -> Bool .
    eq C in (CONT1 C CONT2) = true .
    eq C in (CONT1) = false [owise] .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .

    --- Group of messsages
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM format (d nt d)] .

    var M : Msg .
    vars MS1 MS2 : Msgs .
    
    --- Operation to check the network
    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    --- Defintion of our three main participants followiing the literature
    ops Alice Eve Bob : ->  Identifier [ctor] .

    --- Definition of the default participant
    op none : -> Identifier [ctor] .

    --- Operator to assign a Ciphered text to a participant
    op cI : Identifier Pair -> Content .

    --- Operator to mark the current participant to whom the key exchange is happening
    op peer : Identifier -> Content .

    --- Definition of the components of a Principal
    --- (idenifier [keys] content)
    op _[_]_ : Identifier Keys Content -> Principal [ctor] .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm format (d n d)] .

    --- Global state composed by Samples, Principals and a Network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState [ctor format (n d d n n n d d d d)] .
endfm

--- SIGNATURE scheme behaviour
mod FALCON is
    --- IMPORTS -------------------------------
    protecting DATA-TYPES-EXT .
    protecting FALCON-HASH-OPERATIONS .
    protecting FALCON-KEYGEN .
    protecting FALCON-SIGN .
    protecting FALCON-VERIFY .
    protecting MODEL-CONFIGURATION .

    --- Samples ------------------------------------------------
    
    --- Sample group for phi
    op phis : Content -> Content .
    --- Operator to bind a phi to an Identifier
    op phiI : Identifier Polynomial -> Content .

    --- Sample group for q
    op qs : Content -> Content .
    --- Operator to bind a q to an Identifier
    op qI : Identifier Nat -> Content .

    --- Sample group for m
    op ms : Content -> Content .
    --- Operator to bind an m to an Identifier
    op mI : Identifier String -> Content .

    --- Sample group for r
    op rs : Content -> Content .
    --- Operator to bind a q to an Identifier
    op rI : Identifier Nat -> Content .

    --- Initial states------------------------------------------
    op init1 : -> GlobalState .
    eq init1 = {phis(phi) qs(q) ms(m) rs(r)}< (Alice[emptyK]peer(none)) (Eve[emptyK]peer(none)) (Bob[emptyK]peer(none)) >net(emptyM) .

    --- RULES --------------------------------------------------

    vars ID1 ID2 ID3 : Identifier .
    var PS : Principals .
    vars MSGS MSGS' : Msgs .
    vars K1 K2 : SKey .
    vars PK PK' : PKey .
    vars GAMMA GAMMA' : Pair .
    vars D' S E ER C C' ALPHAQ : Polynomial .
    var M : Polynomial .
    vars KS1 KS2 KS3 : Keys .
    vars AUX ALPHA : List{Data} .
    var SK : Pair .
    var L : List{Data} .
    vars c t : Polynomial .
    vars SAM1 SAM2 : Data .
    var Q : Nat .
    vars CONT1 CONT2 CONT3 CONT4 : Content .

    --- Honest participant behaviour----------------------------

    --- Generation of pair of keys by a participant
    crl [KeyGen] :  {phis(SAM1 CONT1) qs(SAM2 CONT2) CONT3}< (ID1[emptyK]peer(none)) PS >net(emptyM)
                    =>
                    {phis(CONT1) qs(CONT2) CONT3}< (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]qI(ID1,SAM2) / peer(none)) PS >net(emptyM)
                    if  L := NTRUGen(SAM1,SAM2) /\
                        SK := ([FFT(mat(L)),ffLDL(FFT(mat(L)) x FFT(mat(L)))]) /\
                        PK := (elem(2,L) p* inv(elem(1,L))) mod SAM2 .


    --- Signing process of a message created by a participant
    crl [Sign] :    {ms(SAM1 CONT1) rs(SAM2 CONT2) CONT3}< (ID1[secretKey(ID1,SK) ; KS1]qI(ID1,Q) / peer(none)) PS >net(emptyM)
                    =>
                    {ms(SAM1 CONT1) rs(SAM2 CONT2) CONT3}< (ID1[secretKey(ID1,SK) ; KS1]qI(ID1,Q) / peer(none)) PS >net(emptyM)
                    if  c := HashToPoint(SAM2||SAM1, Q, n) /\
                        t := (FFT(c), FFT(0)) * first(SK) .


    --- Intruder behaviour--------------------------------------
    
endm