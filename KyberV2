ANOTACIONES SOBRE EL PROTOCOLO KYBER

------------------------------------------------------------------------------------------------------------------------

1.1 Hacer historico de mensajes al lado de los participantes

1.2 Representar el estado del participante

1.5 Usar condiciones para generar pk, sk, k y ciph

------------------------------------------------------------------------------------------------------------------------

2. Mirar objetos de Maude para representar Alice y Bob. Con ello
hacer una primera versión de Kyber donde estos objetos se envian mensajes
con origen y denstino, guardando información local para luego comprobar que coincide con la enviada por el otro.

2.1 En maudeNPA hay variables frescas

------------------------------------------------------------------------------------------------------------------------

3.1 Para hacer lo de las matrices usaremos symbolos de tipo Matriz

3.2 Se puede uno fijar en las la especificación del protocolo de usar las funciones compress y decompress para generar lo que necesitemos

3.3 Fijarse en las lineas 301 y 329 de kyber.maude. Pueden ser útiles para especificar el churro de las matrices

3.4 Se puede utilizar una función f que sea la que cumple lo de Diffie Hellman de Santiago y Damián

Lo que podemos hacer es especificar las funciones y operaciones que generan los componentes necesarios. Por ejemplo, para el caso de KeyGen podemos especificar la operación || sobre 
vectores para así obtener pk.
------------------------------------------------------------------------------------------------------------------------

ME GUARDO ESTA PARTE POR SI HACE FALTA MÁS ADELANTE
---Equations representing the tuple of functions
    ---KeyGen() -> (sk,pk)
    vars pk sk : Key .
    op KG : -> Instr .
    eq [KeyGen] <Alice(KG[emptyK]emptyM)|P1|P2> = <Alice(emptyI[pk|sk]{(Alice,Bob)[sent]})|P1|P2> .
    
    ---Encaps(pk) -> (k,c)
    var k : Key .
    var c : Ciphertext .
    op ENC : Key -> Instr .
    eq [Encaps] ENC(pk) = (k,c) .

    ---Decaps(sk,c) -> k
    op DEC : Ciphertext Key -> Instr .
    eq [Decaps] DEC(c,sk) = k .
