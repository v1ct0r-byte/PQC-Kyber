ANOTACIONES SOBRE EL PROTOCOLO KYBER

------------------------------------------------------------------------------------------------------------------------
NOTACIONES REUNION 1

1.1 Hacer historico de mensajes al lado de los participantes

1.2 Representar el estado del participante

1.5 Usar condiciones para generar pk, sk, k y ciph

------------------------------------------------------------------------------------------------------------------------
NOTACIONES REUNION 2

2. Mirar objetos de Maude para representar Alice y Bob. Con ello
hacer una primera versión de Kyber donde estos objetos se envian mensajes
con origen y denstino, guardando información local para luego comprobar que coincide con la enviada por el otro.

2.1 En maudeNPA hay variables frescas

------------------------------------------------------------------------------------------------------------------------
NOTACIONES REUNION 3

3.1 Para hacer lo de las matrices usaremos symbolos de tipo Matriz

3.2 Se puede uno fijar en la especificación del protocolo de usar las funciones compress y decompress para generar lo que necesitemos

3.3 Fijarse en las lineas 301 y 329 de kyber.maude. Pueden ser útiles para especificar el churro de las matrices

3.4 Se puede utilizar una función f que sea la que cumple lo de Diffie Hellman de Santiago y Damián

Lo que podemos hacer es especificar las funciones y operaciones que generan los componentes necesarios. Por ejemplo, para el caso de KeyGen podemos especificar la operación || sobre 
vectores para así obtener pk.

------------------------------------------------------------------------------------------------------------------------
NOTACIONES REUNION 4

4.1 la t se encuentra en el envío del mensaje al hacer KeyGen

4.2 Abstraer la implementación a símbolos con sus operaciones

------------------------------------------------------------------------------------------------------------------------
NOTACIONES MATEMÁTICAS IMPORTANTES

-> Beta es un conjunto de números enteros que abarca de 0 a 255, por ejemplo el conjunto de enteros de 8-bit sin signo.
-> Beta^k es el conjunto de cadenas de bytes con longitud k.
-> Beta^* es el conjunto de cadenas de bytes con longitud arbitraria.
-> Dadas dos cadenas de bytes a y b, (a||b) representa la concatenación de a y b.
-> El anillo de enteros mod q es Zq, donde los enteros se encuentran en el rango [0,q).
-> R es el anillo de polinomios (algo muy profundo).
-> En KYBER los valores de n = 7681 y q = 256.

-> Existen dos funciones hash:
    H : B^* -> B^32, es una función que recibe enteros de longitud arbitraria y devuelve un entero de longitud 32 (o un vector de dicha longitud).
    G : B^* -> B^32 x B^3, es una función que recibe también enteros de longitud arbitraria pero devuelve una matriz de tamaño 32x32.
-> KDF (key derivation function) : B^* -> B^32.
-> Q son los números racionales (son aquellos números que pueden representarse como el cociente de dos números enteros).
-> [x] indica la aproximación al entero mas cercano (por techo o suelo) cuando x pertence a Q.
-> Siendo x un número del anillo de enteros hasta q = 256, y sea d < [log2q]:
    La función de compresión sobre q recibe la x y un d
    La función de decpmpresión sobre q recibe la x y un d
-> CBD significa Centered binomial distribution. Representa el dominio de donde son sacadas las muestras de forma pseudoaleatorias para los vectores/arrays de bytes u y v.
------------------------------------------------------------------------------------------------------------------------
FUNCIONAMIENTO DEL PROTOCOLO USANDO NOTACIONES MATEMÁTICAS



------------------------------------------------------------------------------------------------------------------------
ME GUARDO ESTA PARTE POR SI HACE FALTA MÁS ADELANTE
---Equations representing the tuple of functions
    ---KeyGen() -> (sk,pk)
    vars pk sk : Key .
    op KG : -> Instr .
    eq [KeyGen] <Alice(KG[emptyK]emptyM)|P1|P2> = <Alice(emptyI[pk|sk]{(Alice,Bob)[sent]})|P1|P2> .
    
    ---Encaps(pk) -> (k,c)
    var k : Key .
    var c : Ciphertext .
    op ENC : Key -> Instr .
    eq [Encaps] ENC(pk) = (k,c) .

    ---Decaps(sk,c) -> k
    op DEC : Ciphertext Key -> Instr .
    eq [Decaps] DEC(c,sk) = k .

--- Rule that models the function KeyGen for Alice
crl [KeyGen] : < (Alice[emptyK]emptyC) PS >net(emptyM) => < (Alice[publicKey(Alice,PK) ; secretKey(Alice,SK)]emptyC) PS >net(emptyM)
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .

--- Rules to send and receive a key between two participants
crl [SendPK] : < (ID1[PK ; KS1]CONT1) (ID2[KS2]CONT2) PS >net(emptyM) => < (ID1[PK ; KS1]CONT1) (ID2[KS2]CONT2) PS >net(msg{(ID1,ID2)[sent]PK})
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .

crl [RecievePK] : < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sent]PK}) => < (ID1[PK ; KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[received]PK})
        if SK := sampleS(second(G(d))) /\ 
        PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) .

--- Rules to send and receive a chipered text
crl [SendCiph] : < (ID1[KS1]C CONT1) PS >net(MSGS msg{(ID2,ID1)[consumed]PK}) => < (ID1[KS1]C CONT1) PS >net(MSGS msg{(ID2,ID1)[consumed]PK} msg{(ID1,ID2)[sent](C)})
    if SK := sampleS(second(G(d))) /\ 
    PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
    U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
    V := (((tpV(PK) dot sampleR'(r)) v+ sampleE2(r)) v+ Decompress(m,1)) /\
    C1 := Compress(U,du) /\
    C2 := Compress(V,dv) /\
    C := (C1,C2) .

crl [RecieveCiph] : < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sent](C)}) => < (ID1[KS1]CONT1 (C)) PS >net(MSGS msg{(ID2,ID1)[received](C)})
    if SK := sampleS(second(G(d))) /\
    PK := ((generateA(first(G(d))) m* SK) v+ sampleE(second(G(d)))) /\
    U := ((tpM(generateA(first(G(d)))) m* sampleR'(r)) v+ sampleE1(r)) /\
    V := ((tpV(PK) dot sampleR'(r)) v+ sampleE2(r) v+ Decompress(m,1)) /\
    C1 := Compress(U,du) /\
    C2 := Compress(V,dv) /\
    C := (C1,C2) .

--- Modulo antes de cambiar los samples y meterlos en keygen y enc

--- Specification of CRYSTALS-KYBER till step 5

--- Module specifying basic datatypes and its operations used in KYBER
fmod DATA-TYPES is
    protecting INT .
    --- Here we are subsuming all sizes of vectors (and abstract that all vectors are column vectors)
    --- We also define type for matrices and polynomials
    sorts Vector Matrix .

    --- We specify that a vector is a also a matrix
    subsort Vector < Matrix .

    --- We specify numbers are vectors
    subsort Nat < Vector .

    vars V1 V2 V3 : Vector .

    --- Concatenation of vectors result in a new vector
    op _||_ : Vector Vector -> Vector .

    --- Operator for the sum of vectors
    op _v+_ : Vector Vector -> Vector [assoc comm] .

    --- Necessary equations for Dec step
    --- Identity element is 0
    eq V1 v+ 0 = V1 .

    --- Operator for the substraction of vectors
    op _v-_ : Vector Vector -> Vector [assoc] .

    --- Necessary equations for Dec step
    eq V1 v- V1 = 0 .
    eq (V1 v+ V2) v- V1 = V2 .
    --- This one is the most important because it allows us to eliminate ((A m* s) dot r)
    eq (V1 v+ V2) v- (V1 v+ V3) = V2 v- V3 .
    eq V1 v- 0 = V1 .

    --- Operator multiplication of a vector and a vector
    op _dot_ : Vector Vector -> Vector [assoc] .

    --- Equation to specify the distributive property of dot over v+
    eq (V1 v+ V2) dot V3 = (V1 dot V3) v+ (V2 dot V3) .
    eq V1 dot (V2 v+ V3) = (V1 dot V2) v+ (V1 dot V3) .

    var M1 : Matrix .

    --- Operator multiplication of a matrix and a vector
    op _m*_ : Matrix Vector -> Vector .

    --- Distributive property of dot over m*
    eq (M1 m* V1) dot V2 = V1 dot (M1 m* V2) .

    --- Pair
    sort Pair .

    --- A Pair can be seen as a Vector divided in two parts
    subsort Pair < Vector .

    op _,_ : Vector Vector -> Pair .

    --- First element of Pair
    op first : Pair -> Vector .
    eq first((V1,V2)) = V1 .
    --- Second element of Pair
    op second : Pair -> Vector .
    eq second((V1,V2)) = V2 .

    --- Constant and values necessary on modules for operations

    --- du and dv are integer parameters of CPAPKE in ENC and DEC
    ops du dv : -> NzNat .

    --- Rho and Sigma
    ops Rho1 Sig1 : -> Vector .
    ops Rho2 Sig2 : -> Vector .
    ops Rho3 Sig3 : -> Vector .

    --- Operation to represent the traspose of a given matrix or vector
    op tpM : Matrix -> Matrix .
    op tpV : Vector -> Vector .

    --- We define the distribution of the operation traspose over v+ and m*
    eq tpV(V1 v+ V2) = tpV(V1) v+ tpV(V2) .
    eq tpV(M1 m* V1) = tpM(M1) m* tpV(V1) . 
endfm

--- Module to specify all the hash functions that are used in the steps of KYBER KEM
fmod KYBER-HASH-OPERATIONS is
    protecting DATA-TYPES .

    --- H recieves a random vector and returns a hash of it (which is also a vector)
    op H : Vector -> Vector .

    --- Sample values taken from the set of byte-arrays of length 32
    ops d1 d2 d3 : -> Vector .

    --- G recieves a random number (vector) from the polynomial ring R and returns a pair of vectors
    op G : Vector -> Pair .
    eq G(d1) = (Rho1,Sig1) .
    eq G(d2) = (Rho2,Sig2) .
    eq G(d3) = (Rho3,Sig3) .
endfm

--- Module to specifiy basic operations on data
fmod ENCRYPTION is
    protecting DATA-TYPES .

    --- Operators to compress and decompress
    ops Compress Decompress : Vector NzNat -> Vector .

    --- We assume the property leaves X ass the same, in practice this 
    --- is not true but a new X' is obteined which is close to X
    vars X V1 V2 : Vector .
    var N : NzNat .

    --- Property of interest
    eq Decompress(Compress(X,N),N) = X .
    eq Compress(Decompress(X,N),N) = X .

    --- Property of noise cancelation
    eq  (V1 v+ Decompress(X,N)) v- V2 = Decompress(X,N) .
endfm

--- Module to represent the operations and data handled during KEYGEN
fmod KYBER-CPAPKE-KEYGEN is
    protecting DATA-TYPES .

    --- Public Square matrix A
    ops A1 A2 A3 A4 A5 : -> Matrix .

    --- Operator to generate a matrix from the FIRST vector given by G(d)
    op generateA : Vector  -> Matrix .
    eq generateA(Rho1) = A1 .
    eq generateA(Rho2) = A2 .
    eq generateA(Rho3) = A3 .

    --- Constant values to represent s and e
    ops s1 e : -> Vector .
    ops s2 e' : -> Vector .
    ops s3 e'' : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleS sampleE : Vector -> Vector .
    eq sampleS(Sig1) = s1 .
    eq sampleE(Sig1) = e .

    eq sampleS(Sig2) = s2 .
    eq sampleE(Sig2) = e' .

    eq sampleS(Sig3) = s3 .
    eq sampleE(Sig3) = e'' .
endfm

--- Module to represent the operations and data handled during ENC
fmod KYBER-CPAPKE-ENC is
    protecting DATA-TYPES .
    protecting ENCRYPTION .

    --- Message randomply generated by a principal
    ops m1 m2 m3 : -> Vector .

    --- Constant to represent the chosen coin r and the sampleR r'
    ops r1 r1' : -> Vector .
    ops r2 r2' : -> Vector .
    ops r3 r3' : -> Vector .

    op sampleR' : Vector -> Vector . 
    eq sampleR'(r1) = r1' .
    eq sampleR'(r2) = r2' .
    eq sampleR'(r3) = r3' .

    ops e11 e21 : -> Vector .
    ops e11 e21 : -> Vector .
    ops e11 e21 : -> Vector .

    --- Operators to sample vectors s and e from the SECOND vector given by G(d)
    ops sampleE1 sampleE2 : Vector -> Vector .
    eq sampleE1(r1) = e11 .
    eq sampleE2(r1) = e21 .
endfm

--- Module to represent the operations and data handled during DEC
--- Its main purpouse is to demonstrate that the computed key is
--- the one that originated c in Bob side using PK
fmod KYBER-CPAPKE-DEC is
    protecting DATA-TYPES .

    
endfm

--- CRYSTALS-KYBER
mod KYBERV2 is
    --- IMPORTS-------------------------------
    ---protecting DATA-TYPES .
    protecting KYBER-HASH-OPERATIONS .
    protecting ENCRYPTION .
    protecting KYBER-CPAPKE-KEYGEN .
    protecting KYBER-CPAPKE-ENC .

    --- SORTS---------------------------------
    
    sorts Identifier Principal Content Principals . 
    sorts MsgState Msg Msgs .
    subsort Msg < Msgs .
    subsort Principal < Principals .

    sorts Key Keys .
    subsort Key < Keys .

    --- We distinguish between public and secret keys, both being keys in the end
    sorts PKey SKey .

    ---We define keys as a type of content
    subsorts Vector < PKey SKey < Key < Content .

    --- We also declare that a pair is content
    subsort Pair < Content .

    sort GlobalState .
    
    --- OPERATORS----------------------------
    --- Empty group of keys
    op emptyK : -> Keys .
    --- Group of keys
    op _;_ : Keys Keys -> Keys [assoc id: emptyK comm] .

    --- Operator to represent the relation of a public key and a principal
    op publicKey : Identifier Key -> PKey .

    --- Operator to represent the relation of a secret key and a principal
    op secretKey : Identifier Key -> SKey .

    --- Operator to represent the shared key with a participant
    op sharedKey : Identifier Key -> SKey .

    --- Posible states for a message
    ops sent received intercepted : -> MsgState .

    --- Empty content
    op emptyC : -> Content .
    --- Group of contents
    op __ : Content Content -> Content [assoc id: emptyC comm] .

    --- We declare a sort for all the list of samples
    ---sorts Sample Samples .
    ---subsorts Vector < Sample < Samples .

    op emptyS : -> Content .

    --- Group of vectors d that can be sampled
    op ds : Content -> Content .

    --- Group of messages m that can be sampled
    op ms : Content -> Content .

    --- Group of coins r that can be sampled
    op rs : Content -> Content .

    --- Operator to assign a vector 'd' to a participant
    op dI : Identifier Vector -> Content .

    --- Operator to assign a message to a participant
    op mI : Identifier Vector -> Content .

    --- Operator to assign a random coin to a participant
    op rI : Identifier Vector -> Content .

    --- Structure of a message
    --- Sender, Receiver, State, Content
    op msg{(_,_)[_]_} : Identifier Identifier MsgState Content -> Msg .
    op emptyM : -> Msgs .
    op __ : Msgs Msgs -> Msgs [assoc id: emptyM] .

    --- Operation to check the network
    var M : Msg .
    vars MS1 MS2 : Msgs .

    op _in_ : Msg Msgs -> Bool .

    eq M in (MS1 M MS2) = true .
    eq M in (MS1) = false [owise] .

    ops Alice Eve Bob : ->  Identifier .
    --- Definition of the components of a Principal
    --- (idenifier that can be Alice, Bob or Eve [keys received or generated] content that the principal stores)
    op _[_]_ : Identifier Keys Content -> Principal .

    --- Group of principals
    op __ : Principal Principal -> Principals [assoc comm] .

    --- Global state composed by Principals and a network with messages
    op {_}<_>net(_) : Content Principals Msgs -> GlobalState .
    op True : -> GlobalState .

    --- RULES-------------------------------------------------------------------------------------------------------------
    
    vars P1 P2 : Principal .
    vars ID1 ID2 : Identifier .
    var PS : Principals .
    vars MSGS MSGS2 : Msgs .
    vars K SK : SKey .
    vars PK PK' : PKey .
    var U V U' V' : Vector .
    var KS1 KS2 : Keys .
    vars C1 C2 : Vector .
    vars SAM1 SAM2 SAM3 : Vector .
    var C : Pair .
    var CONT CONT1 CONT2 : Content .
    vars V1 V2 V3 : Vector .

    --- For simplyfing reasons we only sample d when there is no message on the network
    rl [SampleD] : { ds(SAM1 CONT emptyS) CONT1 } < (ID1[emptyK]emptyC) PS >net(emptyM) => { ds(CONT emptyS) CONT1 } < (ID1[emptyK]dI(ID1,SAM1)) PS >net(emptyM) .

    --- For now the protocol only starts when the participant has sampled necesary values for keygen
    crl [KeyGen] : { CONT } < (ID1[emptyK]dI(ID1,SAM1) CONT1) PS >net(MSGS) => { CONT } < (ID1[publicKey(ID1,PK) ; secretKey(ID1,SK)]dI(ID1,SAM1) CONT1) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\ 
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) .

    --- Send PK to someone if it has not been sent before and the reciever didnt recieve it before
    crl [SendPK] : { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) PS >net(MSGS) => { CONT } < (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM1) CONT1) (ID2[KS2]CONT2) PS >net(MSGS msg{(ID1,ID2)[sent]PK})
        if SK := sampleS(second(G(SAM1))) /\ 
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) /\ 
        (msg{(ID1,ID2)[sent]PK}) in MSGS == false /\ 
        (msg{(ID1,ID2)[received]PK}) in MSGS == false .

    rl [RecievePK] : { CONT } < (ID2[KS2]CONT2) (ID1[KS1]dI(ID1,SAM1) CONT1) PS >net(MSGS msg{(ID1,ID2)[sent]PK} MSGS2) => { CONT } < (ID2[publicKey(ID1,PK) ; KS2]CONT2) (ID1[KS1]dI(ID1,SAM1) CONT1) PS >net(MSGS msg{(ID1,ID2)[received]PK} MSGS2) .
        ---if SK := sampleS(second(G(SAM1))) /\
        ---PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) .
    
    --- Generation of ms when a participant has the pk of another participant
    crl [SampleM] : { ms(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]CONT1) PS >net(MSGS) => { ms(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM1) CONT1) PS >net(MSGS) 
        if  ID1 =/= ID2 .

    --- Generation of rs right after generating m
    rl [SampleR] : { rs(SAM1 CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]mI(ID1,SAM2) CONT1) PS >net(MSGS) => { rs(CONT emptyS) CONT2 } < (ID1[publicKey(ID2,PK) ; KS1]rI(ID1,SAM1) mI(ID1,SAM2) CONT1) PS >net(MSGS) .

    crl [Enc] : { CONT } < (ID2[publicKey(ID1,PK) ; KS2]mI(ID2,SAM1) rI(ID2,SAM2) CONT2) (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM3) CONT1) PS >net(MSGS) => { CONT } < (ID2[sharedKey(ID1,SAM1) ; publicKey(ID1,PK) ; KS2]C mI(ID2,SAM1) rI(ID2,SAM2) CONT2) (ID1[publicKey(ID1,PK) ; KS1]dI(ID1,SAM3) CONT1) PS >net(MSGS)
        if U := ((tpM(generateA(first(G(SAM3)))) m* sampleR'(SAM2)) v+ sampleE1(SAM2)) /\
        V := (((tpV(PK) dot sampleR'(SAM2)) v+ sampleE2(SAM2)) v+ Decompress(SAM1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) .

    crl [SendCiph] : { CONT } < (ID2[sharedKey(ID1,SAM1) ; KS1]C CONT1) PS >net(MSGS) => { CONT } < (ID2[sharedKey(ID1,SAM1) ; KS1]C CONT1) PS >net(MSGS msg{(ID2,ID1)[sent](C)})
        if SK := sampleS(second(G(d1))) /\ 
        PK := ((generateA(first(G(d1))) m* SK) v+ sampleE(second(G(d1)))) /\
        U := ((tpM(generateA(first(G(d1)))) m* sampleR'(r1)) v+ sampleE1(r1)) /\
        V := (((tpV(PK) dot sampleR'(r1)) v+ sampleE2(r1)) v+ Decompress(m1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\
        msg{(ID2,ID1)[sent](C)} in MSGS == false /\
        msg{(ID2,ID1)[received](C)} in MSGS == false .

    rl [RecieveCiph] : { CONT } < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[sent](C)}) => { CONT } < (ID1[KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[received](C)}) .
        ---if SK := sampleS(second(G(d1))) /\
        ---PK := ((generateA(first(G(d1))) m* SK) v+ sampleE(second(G(d1)))) /\
        ---U := ((tpM(generateA(first(G(d1)))) m* sampleR'(r1)) v+ sampleE1(r1)) /\
        ---V := ((tpV(PK) dot sampleR'(r1)) v+ sampleE2(r1) v+ Decompress(m1,1)) /\
        ---C1 := Compress(U,du) /\
        ---C2 := Compress(V,dv) /\
        ---C := (C1,C2) .

    crl [Dec] : { CONT } < (ID1[secretKey(ID1,SK) ; KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[received](C)}) => { CONT } < (ID1[secretKey(ID1,SK) ; sharedKey(ID2,K) ; KS1]CONT1) PS >net(MSGS msg{(ID2,ID1)[received](C)})
        if SK := sampleS(second(G(d1))) /\
        PK := ((generateA(first(G(d1))) m* SK) v+ sampleE(second(G(d1)))) /\
        U := ((tpM(generateA(first(G(d1)))) m* sampleR'(r1)) v+ sampleE1(r1)) /\
        V := (((tpV(PK) dot sampleR'(r1)) v+ sampleE2(r1)) v+ Decompress(m1,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K := Compress(V' v- tpV(SK) dot U',1) .

    rl [Comp] : { CONT } < (ID1[sharedKey(ID2,K) ; KS1]CONT1) (ID2[sharedKey(ID1,K) ; KS2]CONT2) PS >net(MSGS) => True .

    --- Intruder behaviour
    crl [Intercept] : { CONT } < (Eve[publicKey(Eve,PK) ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[sent]PK'}) => { CONT } < (Eve[publicKey(Eve,PK) ; publicKey(Alice,PK') ; KS1]CONT1) (Alice[publicKey(Alice,PK') ; KS2]CONT2) PS >net(MSGS msg{(Alice,Bob)[intercepted]PK'} msg{(Alice,Bob)[sent]PK}) 
        if (msg{(Alice,Bob)[intercepted]PK'}) in MSGS == false .

    --- crl []

    --- Initial state-------------------------------------------------------------------------------------------------------------
    
    op init : -> GlobalState .
    eq init = {ds(d1 d2 emptyS) ms(m1 m2 emptyS) rs(r1 r2 emptyS)} < (Alice[emptyK]emptyC) (Eve[emptyK]emptyC) (Bob[emptyK]emptyC) >net(emptyM) .
endm

--- Once decompressed, the ciphertext is destroyed from local memory of the participant
    crl [Dec] : { CONT } < (ID1[secretKey(ID1,SK) ; KS1]dI(ID1,SAM1) cI(ID2,C) CONT1) (ID2[sharedKey(ID1,SAM2) ; KS2]cI(ID2,C) mI(ID2,SAM2) rI(ID2,SAM3) CONT2) PS >net(MSGS) => { CONT } < (ID1[secretKey(ID1,SK) ; sharedKey(ID2,K) ; KS1]dI(ID1,SAM1) CONT1) (ID2[sharedKey(ID1,SAM2) ; KS2]cI(ID2,C) mI(ID2,SAM2) rI(ID2,SAM3) CONT2) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) /\
        U := ((tpM(generateA(first(G(SAM1)))) m* sampleR'(SAM3)) v+ sampleE1(SAM3)) /\
        V := (((tpV(PK) dot sampleR'(SAM3)) v+ sampleE2(SAM3)) v+ Decompress(SAM2,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K := Compress(V' v- tpV(SK) dot U',1) .

--- Once decompressed, the ciphertext is destroyed from local memory of the participant
    crl [Dec] : { CONT } < (ID1[secretKey(ID1,SK) ; KS1]dI(ID1,SAM1) cI(ID2,C') CONT1) (ID3[sharedKey(ID1,SAM2) ; KS2]mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS) => { CONT } < (ID1[secretKey(ID1,SK) ; sharedKey(ID2,K) ; KS1]dI(ID1,SAM1) CONT1) (ID3[sharedKey(ID1,SAM2) ; KS2]mI(ID3,SAM2) rI(ID3,SAM3) CONT2) PS >net(MSGS)
        if SK := sampleS(second(G(SAM1))) /\
        PK := ((generateA(first(G(SAM1))) m* SK) v+ sampleE(second(G(SAM1)))) /\
        U := ((tpM(generateA(first(G(SAM1)))) m* sampleR'(SAM3)) v+ sampleE1(SAM3)) /\
        V := (((tpV(PK) dot sampleR'(SAM3)) v+ sampleE2(SAM3)) v+ Decompress(SAM2,1)) /\
        C1 := Compress(U,du) /\
        C2 := Compress(V,dv) /\
        C := (C1,C2) /\ 
        U' := Decompress(first(C),du) /\
        V' := Decompress(second(C),dv) /\
        K := Compress(V' v- tpV(SK) dot U',1) /\
        ID1 =/= ID2 .